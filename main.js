/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StoryWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian11 = require("obsidian");

// src/services/ProjectService.ts
var import_obsidian = require("obsidian");

// src/services/MetadataManager.ts
var MetadataManager = class {
  constructor(app) {
    this.app = app;
    this.fileManager = app.fileManager;
  }
  /**
   * 安全读取文件的 YAML frontmatter
   * Safely read YAML frontmatter from file
   */
  async readMetadata(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      return (metadata == null ? void 0 : metadata.frontmatter) || null;
    } catch (error) {
      console.error(`Failed to read metadata from ${file.path}:`, error);
      throw new Error(`Failed to read metadata: ${error.message}`);
    }
  }
  /**
   * 安全写入文件的 YAML frontmatter
   * Safely write YAML frontmatter to file
   */
  async writeMetadata(file, metadata) {
    try {
      await this.fileManager.processFrontMatter(file, (frontmatter) => {
        Object.keys(frontmatter).forEach((key) => {
          delete frontmatter[key];
        });
        Object.assign(frontmatter, metadata);
      });
    } catch (error) {
      console.error(`Failed to write metadata to ${file.path}:`, error);
      throw new Error(`Failed to write metadata: ${error.message}`);
    }
  }
  /**
   * 更新文件的部分 YAML frontmatter
   * Update partial YAML frontmatter in file
   */
  async updateMetadata(file, updates) {
    try {
      await this.fileManager.processFrontMatter(file, (frontmatter) => {
        Object.assign(frontmatter, updates);
      });
    } catch (error) {
      console.error(`Failed to update metadata in ${file.path}:`, error);
      throw new Error(`Failed to update metadata: ${error.message}`);
    }
  }
  /**
   * 删除文件中的特定 YAML 字段
   * Remove specific YAML fields from file
   */
  async removeMetadataFields(file, fields) {
    try {
      await this.fileManager.processFrontMatter(file, (frontmatter) => {
        fields.forEach((field) => {
          delete frontmatter[field];
        });
      });
    } catch (error) {
      console.error(`Failed to remove metadata fields from ${file.path}:`, error);
      throw new Error(`Failed to remove metadata fields: ${error.message}`);
    }
  }
  /**
   * 验证场景元数据
   * Validate scene metadata
   */
  validateSceneMetadata(metadata) {
    const errors = [];
    const warnings = [];
    if (metadata.title !== void 0 && typeof metadata.title !== "string") {
      errors.push("Title must be a string");
    }
    if (metadata.status !== void 0) {
      const validStatuses = ["outline", "draft", "revised", "complete"];
      if (!validStatuses.includes(metadata.status)) {
        errors.push(`Status must be one of: ${validStatuses.join(", ")}`);
      }
    }
    if (metadata.wordCount !== void 0) {
      if (typeof metadata.wordCount !== "number" || metadata.wordCount < 0) {
        errors.push("Word count must be a non-negative number");
      }
    }
    if (metadata.chapterIndex !== void 0) {
      if (typeof metadata.chapterIndex !== "number" || metadata.chapterIndex < 0) {
        errors.push("Chapter index must be a non-negative number");
      }
    }
    if (metadata.sceneIndex !== void 0) {
      if (typeof metadata.sceneIndex !== "number" || metadata.sceneIndex < 0) {
        errors.push("Scene index must be a non-negative number");
      }
    }
    if (metadata.storyTime !== void 0 && metadata.storyTime !== null) {
      if (!(metadata.storyTime instanceof Date) && typeof metadata.storyTime !== "string") {
        errors.push("Story time must be a Date object or ISO string");
      }
    }
    if (metadata.tags !== void 0) {
      if (!Array.isArray(metadata.tags)) {
        errors.push("Tags must be an array");
      } else if (!metadata.tags.every((tag) => typeof tag === "string")) {
        errors.push("All tags must be strings");
      }
    }
    if (metadata.synopsis !== void 0 && metadata.synopsis.length > 200) {
      warnings.push("Synopsis is quite long (>200 characters)");
    }
    if (metadata.wordCount !== void 0 && metadata.wordCount > 1e4) {
      warnings.push("Scene word count is very high (>10,000 words)");
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 验证角色元数据
   * Validate character metadata
   */
  validateCharacterMetadata(metadata) {
    const errors = [];
    const warnings = [];
    if (metadata.name !== void 0 && typeof metadata.name !== "string") {
      errors.push("Name must be a string");
    }
    if (metadata.status !== void 0) {
      const validStatuses = ["alive", "dead", "unknown"];
      if (!validStatuses.includes(metadata.status)) {
        errors.push(`Status must be one of: ${validStatuses.join(", ")}`);
      }
    }
    if (metadata.age !== void 0) {
      if (typeof metadata.age !== "number" || metadata.age < 0 || metadata.age > 1e3) {
        errors.push("Age must be a number between 0 and 1000");
      }
    }
    if (metadata.relationships !== void 0) {
      if (!Array.isArray(metadata.relationships)) {
        errors.push("Relationships must be an array");
      } else if (!metadata.relationships.every((rel) => typeof rel === "string")) {
        errors.push("All relationships must be strings");
      }
    }
    if (metadata.appearances !== void 0) {
      if (!Array.isArray(metadata.appearances)) {
        errors.push("Appearances must be an array");
      } else if (!metadata.appearances.every((app) => typeof app === "string")) {
        errors.push("All appearances must be strings");
      }
    }
    if (metadata.description !== void 0 && metadata.description.length > 1e3) {
      warnings.push("Description is quite long (>1000 characters)");
    }
    if (metadata.age !== void 0 && metadata.age > 200) {
      warnings.push("Character age is very high (>200 years)");
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 验证地点元数据
   * Validate location metadata
   */
  validateLocationMetadata(metadata) {
    const errors = [];
    const warnings = [];
    if (metadata.name !== void 0 && typeof metadata.name !== "string") {
      errors.push("Name must be a string");
    }
    if (metadata.connectedLocations !== void 0) {
      if (!Array.isArray(metadata.connectedLocations)) {
        errors.push("Connected locations must be an array");
      } else if (!metadata.connectedLocations.every((loc) => typeof loc === "string")) {
        errors.push("All connected locations must be strings");
      }
    }
    if (metadata.scenes !== void 0) {
      if (!Array.isArray(metadata.scenes)) {
        errors.push("Scenes must be an array");
      } else if (!metadata.scenes.every((scene) => typeof scene === "string")) {
        errors.push("All scenes must be strings");
      }
    }
    if (metadata.description !== void 0 && metadata.description.length > 1e3) {
      warnings.push("Description is quite long (>1000 characters)");
    }
    if (metadata.connectedLocations !== void 0 && metadata.connectedLocations.length > 20) {
      warnings.push("Very many connected locations (>20)");
    }
    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }
  /**
   * 将场景数据转换为 YAML frontmatter 格式
   * Convert scene data to YAML frontmatter format
   */
  sceneDataToYaml(sceneData) {
    const yaml = {};
    if (sceneData.title !== void 0)
      yaml.title = sceneData.title;
    if (sceneData.status !== void 0)
      yaml.status = sceneData.status;
    if (sceneData.pov !== void 0)
      yaml.pov = sceneData.pov;
    if (sceneData.location !== void 0)
      yaml.location = sceneData.location;
    if (sceneData.storyTime !== void 0) {
      yaml.story_time = sceneData.storyTime instanceof Date ? sceneData.storyTime.toISOString() : sceneData.storyTime;
    }
    if (sceneData.synopsis !== void 0)
      yaml.synopsis = sceneData.synopsis;
    if (sceneData.wordCount !== void 0)
      yaml.word_count = sceneData.wordCount;
    if (sceneData.chapterIndex !== void 0)
      yaml.chapter_index = sceneData.chapterIndex;
    if (sceneData.sceneIndex !== void 0)
      yaml.scene_index = sceneData.sceneIndex;
    if (sceneData.tags !== void 0)
      yaml.tags = sceneData.tags;
    return yaml;
  }
  /**
   * 将角色数据转换为 YAML frontmatter 格式
   * Convert character data to YAML frontmatter format
   */
  characterDataToYaml(characterData) {
    const yaml = {};
    if (characterData.name !== void 0)
      yaml.name = characterData.name;
    if (characterData.faction !== void 0)
      yaml.faction = characterData.faction;
    if (characterData.status !== void 0)
      yaml.status = characterData.status;
    if (characterData.age !== void 0)
      yaml.age = characterData.age;
    if (characterData.description !== void 0)
      yaml.description = characterData.description;
    if (characterData.goals !== void 0)
      yaml.goals = characterData.goals;
    if (characterData.relationships !== void 0)
      yaml.relationships = characterData.relationships;
    if (characterData.appearances !== void 0)
      yaml.appearances = characterData.appearances;
    return yaml;
  }
  /**
   * 将地点数据转换为 YAML frontmatter 格式
   * Convert location data to YAML frontmatter format
   */
  locationDataToYaml(locationData) {
    const yaml = {};
    if (locationData.name !== void 0)
      yaml.name = locationData.name;
    if (locationData.region !== void 0)
      yaml.region = locationData.region;
    if (locationData.description !== void 0)
      yaml.description = locationData.description;
    if (locationData.significance !== void 0)
      yaml.significance = locationData.significance;
    if (locationData.connectedLocations !== void 0)
      yaml.connected_locations = locationData.connectedLocations;
    if (locationData.scenes !== void 0)
      yaml.scenes = locationData.scenes;
    return yaml;
  }
  /**
   * 从 YAML frontmatter 解析场景数据
   * Parse scene data from YAML frontmatter
   */
  yamlToSceneData(yaml, filePath) {
    const sceneData = {
      path: filePath
    };
    if (yaml.title)
      sceneData.title = yaml.title;
    if (yaml.status)
      sceneData.status = yaml.status;
    if (yaml.pov)
      sceneData.pov = yaml.pov;
    if (yaml.location)
      sceneData.location = yaml.location;
    if (yaml.story_time) {
      sceneData.storyTime = typeof yaml.story_time === "string" ? new Date(yaml.story_time) : yaml.story_time;
    }
    if (yaml.synopsis)
      sceneData.synopsis = yaml.synopsis;
    if (yaml.word_count !== void 0)
      sceneData.wordCount = yaml.word_count;
    if (yaml.chapter_index !== void 0)
      sceneData.chapterIndex = yaml.chapter_index;
    if (yaml.scene_index !== void 0)
      sceneData.sceneIndex = yaml.scene_index;
    if (yaml.tags)
      sceneData.tags = yaml.tags;
    return sceneData;
  }
  /**
   * 从 YAML frontmatter 解析角色数据
   * Parse character data from YAML frontmatter
   */
  yamlToCharacterData(yaml, filePath) {
    const characterData = {
      path: filePath
    };
    if (yaml.name)
      characterData.name = yaml.name;
    if (yaml.faction)
      characterData.faction = yaml.faction;
    if (yaml.status)
      characterData.status = yaml.status;
    if (yaml.age !== void 0)
      characterData.age = yaml.age;
    if (yaml.description)
      characterData.description = yaml.description;
    if (yaml.goals)
      characterData.goals = yaml.goals;
    if (yaml.relationships)
      characterData.relationships = yaml.relationships;
    if (yaml.appearances)
      characterData.appearances = yaml.appearances;
    return characterData;
  }
  /**
   * 从 YAML frontmatter 解析地点数据
   * Parse location data from YAML frontmatter
   */
  yamlToLocationData(yaml, filePath) {
    const locationData = {
      path: filePath
    };
    if (yaml.name)
      locationData.name = yaml.name;
    if (yaml.region)
      locationData.region = yaml.region;
    if (yaml.description)
      locationData.description = yaml.description;
    if (yaml.significance)
      locationData.significance = yaml.significance;
    if (yaml.connected_locations)
      locationData.connectedLocations = yaml.connected_locations;
    if (yaml.scenes)
      locationData.scenes = yaml.scenes;
    return locationData;
  }
  /**
   * 批量验证和写入元数据
   * Batch validate and write metadata
   */
  async batchUpdateMetadata(updates) {
    const results = {
      success: 0,
      failed: []
    };
    for (const update of updates) {
      try {
        let validation;
        switch (update.type) {
          case "scene":
            validation = this.validateSceneMetadata(update.metadata);
            break;
          case "character":
            validation = this.validateCharacterMetadata(update.metadata);
            break;
          case "location":
            validation = this.validateLocationMetadata(update.metadata);
            break;
          default:
            throw new Error(`Unknown metadata type: ${update.type}`);
        }
        if (!validation.isValid) {
          throw new Error(`Validation failed: ${validation.errors.join(", ")}`);
        }
        await this.updateMetadata(update.file, update.metadata);
        results.success++;
        if (validation.warnings.length > 0) {
          console.warn(`Warnings for ${update.file.path}: ${validation.warnings.join(", ")}`);
        }
      } catch (error) {
        results.failed.push({
          file: update.file.path,
          error: error.message
        });
      }
    }
    return results;
  }
  /**
   * 检查文件是否有有效的 frontmatter
   * Check if file has valid frontmatter
   */
  async hasValidFrontmatter(file) {
    try {
      const content = await this.app.vault.read(file);
      return content.startsWith("---\n") && content.includes("\n---\n");
    } catch (error) {
      console.error(`Failed to check frontmatter for ${file.path}:`, error);
      return false;
    }
  }
  /**
   * 为文件添加默认的 frontmatter（如果不存在）
   * Add default frontmatter to file if it doesn't exist
   */
  async ensureFrontmatter(file, defaultMetadata) {
    try {
      const hasValidFm = await this.hasValidFrontmatter(file);
      if (!hasValidFm) {
        const content = await this.app.vault.read(file);
        const yamlHeader = Object.keys(defaultMetadata).length > 0 ? `---
${Object.entries(defaultMetadata).map(([key, value]) => `${key}: ${JSON.stringify(value)}`).join("\n")}
---

` : "---\n---\n\n";
        const newContent = yamlHeader + content;
        await this.app.vault.modify(file, newContent);
      }
    } catch (error) {
      console.error(`Failed to ensure frontmatter for ${file.path}:`, error);
      throw new Error(`Failed to ensure frontmatter: ${error.message}`);
    }
  }
};

// src/services/ProjectService.ts
var _ProjectService = class {
  /**
   * 私有构造函数，确保单例模式
   * Private constructor to ensure singleton pattern
   */
  constructor(app) {
    /** 当前项目数据 */
    this.currentProject = null;
    /** 场景数据缓存 */
    this.sceneCache = /* @__PURE__ */ new Map();
    /** 角色数据缓存 */
    this.characterCache = /* @__PURE__ */ new Map();
    /** 地点数据缓存 */
    this.locationCache = /* @__PURE__ */ new Map();
    /** 插件设置 */
    this.settings = null;
    /** 缓存是否已初始化 */
    this.cacheInitialized = false;
    /** 防抖定时器 */
    this.debounceTimers = /* @__PURE__ */ new Map();
    /** 事件监听器引用 */
    this.eventRefs = [];
    /** 文件系统监听是否已启用 */
    this.fileSystemListenerEnabled = false;
    this.app = app;
    this.metadataManager = new MetadataManager(app);
  }
  /**
   * 获取 ProjectService 单例实例
   * Get ProjectService singleton instance
   */
  static getInstance(app) {
    if (!_ProjectService.instance) {
      if (!app) {
        throw new Error("App instance is required for first initialization");
      }
      _ProjectService.instance = new _ProjectService(app);
    }
    return _ProjectService.instance;
  }
  /**
   * 销毁单例实例 (用于测试和插件卸载)
   * Destroy singleton instance (for testing and plugin unload)
   */
  static destroyInstance() {
    if (_ProjectService.instance) {
      _ProjectService.instance.cleanup();
      _ProjectService.instance = null;
    }
  }
  /**
   * 更新设置
   * Update settings
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * 加载项目
   * Load project from specified path
   */
  async loadProject(projectPath) {
    try {
      if (this.currentProject && this.currentProject.rootPath !== projectPath) {
        console.log(`Unloading current project: ${this.currentProject.name}`);
        await this.unloadCurrentProject();
      }
      const projectFolder = this.app.vault.getAbstractFileByPath(projectPath);
      if (!projectFolder) {
        throw new Error(`Project path not found: ${projectPath}`);
      }
      const dashboardPath = `${projectPath}/_project.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (!dashboardFile) {
        throw new Error(`Project dashboard not found: ${dashboardPath}`);
      }
      const fileContent = await this.app.vault.read(dashboardFile);
      const frontmatter = this.parseFrontmatter(fileContent);
      if (!frontmatter) {
        throw new Error("Project dashboard missing frontmatter");
      }
      console.log("Loading project with frontmatter:", frontmatter);
      console.log("Target word count from frontmatter:", frontmatter.target_word_count);
      this.currentProject = {
        name: frontmatter.name || "Untitled Project",
        rootPath: projectPath,
        targetWordCount: frontmatter.target_word_count || 1e5,
        currentWordCount: frontmatter.current_word_count || 0,
        createdDate: frontmatter.created_date ? new Date(frontmatter.created_date) : new Date(),
        lastModified: new Date(dashboardFile.stat.mtime),
        synopsis: frontmatter.synopsis || "",
        status: frontmatter.status || "planning",
        settings: {
          templatePath: frontmatter.template_path || `${projectPath}/80_\u6A21\u677F`,
          autoSaveInterval: frontmatter.auto_save_interval || 30,
          enableWordCount: frontmatter.enable_word_count !== false,
          enableTimeline: frontmatter.enable_timeline !== false
        }
      };
      await this.initializeCache();
      this.enableFileSystemListener();
      console.log(`Project loaded successfully: ${this.currentProject.name}`);
    } catch (error) {
      console.error("Failed to load project:", error);
      throw error;
    }
  }
  /**
   * 创建新项目
   * Create new project with specified name and path
   */
  async createProject(name, path) {
    const startTime = performance.now();
    try {
      if (!name || !path) {
        throw new Error("Project name and path are required");
      }
      const existingFolder = this.app.vault.getAbstractFileByPath(path);
      if (existingFolder) {
        throw new Error(`Path already exists: ${path}`);
      }
      console.log(`Creating project: ${name} at ${path}`);
      await Promise.all([
        this.createProjectStructure(path),
        this.createProjectDashboard(name, path)
      ]);
      await this.loadProject(path);
      const endTime = performance.now();
      const duration = Math.round(endTime - startTime);
      console.log(`Project created successfully: ${name} at ${path} (${duration}ms)`);
    } catch (error) {
      const endTime = performance.now();
      const duration = Math.round(endTime - startTime);
      console.error(`Failed to create project after ${duration}ms:`, error);
      throw error;
    }
  }
  /**
   * 更新场景元数据
   * Update scene metadata
   */
  async updateSceneMetadata(path, metadata) {
    try {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!file) {
        throw new Error(`Scene file not found: ${path}`);
      }
      const currentScene = this.sceneCache.get(path);
      if (!currentScene) {
        throw new Error(`Scene not found in cache: ${path}`);
      }
      const validation = this.metadataManager.validateSceneMetadata(metadata);
      if (!validation.isValid) {
        throw new Error(`Invalid metadata: ${validation.errors.join(", ")}`);
      }
      if (validation.warnings.length > 0) {
        console.warn(`Metadata warnings for ${path}: ${validation.warnings.join(", ")}`);
      }
      const updatedScene = {
        ...currentScene,
        ...metadata,
        lastModified: new Date()
      };
      const yamlData = this.metadataManager.sceneDataToYaml(metadata);
      await this.metadataManager.updateMetadata(file, yamlData);
      this.sceneCache.set(path, updatedScene);
      console.log(`Scene metadata updated successfully: ${path}`);
    } catch (error) {
      console.error("Failed to update scene metadata:", error);
      throw error;
    }
  }
  /**
   * 更新角色元数据
   * Update character metadata
   */
  async updateCharacterMetadata(path, metadata) {
    try {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!file) {
        throw new Error(`Character file not found: ${path}`);
      }
      const currentCharacter = this.characterCache.get(path);
      if (!currentCharacter) {
        throw new Error(`Character not found in cache: ${path}`);
      }
      const validation = this.metadataManager.validateCharacterMetadata(metadata);
      if (!validation.isValid) {
        throw new Error(`Invalid metadata: ${validation.errors.join(", ")}`);
      }
      if (validation.warnings.length > 0) {
        console.warn(`Metadata warnings for ${path}: ${validation.warnings.join(", ")}`);
      }
      const updatedCharacter = {
        ...currentCharacter,
        ...metadata
      };
      const yamlData = this.metadataManager.characterDataToYaml(metadata);
      await this.metadataManager.updateMetadata(file, yamlData);
      this.characterCache.set(path, updatedCharacter);
      console.log(`Character metadata updated successfully: ${path}`);
    } catch (error) {
      console.error("Failed to update character metadata:", error);
      throw error;
    }
  }
  /**
   * 更新地点元数据
   * Update location metadata
   */
  async updateLocationMetadata(path, metadata) {
    try {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!file) {
        throw new Error(`Location file not found: ${path}`);
      }
      const currentLocation = this.locationCache.get(path);
      if (!currentLocation) {
        throw new Error(`Location not found in cache: ${path}`);
      }
      const validation = this.metadataManager.validateLocationMetadata(metadata);
      if (!validation.isValid) {
        throw new Error(`Invalid metadata: ${validation.errors.join(", ")}`);
      }
      if (validation.warnings.length > 0) {
        console.warn(`Metadata warnings for ${path}: ${validation.warnings.join(", ")}`);
      }
      const updatedLocation = {
        ...currentLocation,
        ...metadata
      };
      const yamlData = this.metadataManager.locationDataToYaml(metadata);
      await this.metadataManager.updateMetadata(file, yamlData);
      this.locationCache.set(path, updatedLocation);
      console.log(`Location metadata updated successfully: ${path}`);
    } catch (error) {
      console.error("Failed to update location metadata:", error);
      throw error;
    }
  }
  /**
   * 获取项目统计信息
   * Get project statistics
   */
  getProjectStats() {
    if (!this.currentProject) {
      throw new Error("No project loaded");
    }
    const totalWords = this.calculateTotalWords();
    const chapterCount = this.calculateChapterCount();
    const statusInfo = this.getProjectStatusInfo(this.currentProject.status);
    const progress = statusInfo.progress / 100;
    const todayWords = this.calculateTodayWords();
    const stats = {
      totalWords,
      todayWords,
      progress: Math.min(progress, 1),
      // 确保进度不超过100%
      chapterCount,
      sceneCount: this.sceneCache.size,
      characterCount: this.characterCache.size,
      locationCount: this.locationCache.size
    };
    return stats;
  }
  /**
   * 获取项目状态信息
   * Get project status information
   */
  getProjectStatusInfo(status) {
    const statusMap = {
      "planning": { label: "\u6784\u601D\u4E2D", icon: "\u{1F4DD}", progress: 0 },
      "drafting": { label: "\u521D\u7A3F\u4E2D", icon: "\u270F\uFE0F", progress: 25 },
      "revising": { label: "\u4FEE\u6539\u4E2D", icon: "\u{1F4D6}", progress: 50 },
      "editing": { label: "\u6821\u5BF9\u4E2D", icon: "\u{1F50D}", progress: 75 },
      "completed": { label: "\u5DF2\u5B8C\u6210", icon: "\u2705", progress: 100 }
    };
    return statusMap[status] || statusMap.planning;
  }
  /**
   * 更新项目状态
   * Update project status
   */
  async updateProjectStatus(newStatus) {
    console.log(`\u{1F680} updateProjectStatus called with: ${newStatus}`);
    if (!this.currentProject) {
      console.error("\u274C No project loaded");
      throw new Error("No project loaded");
    }
    console.log(`\u{1F4CB} Current project: ${this.currentProject.name}, current status: ${this.currentProject.status}`);
    const validStatuses = ["planning", "drafting", "revising", "editing", "completed"];
    if (!validStatuses.includes(newStatus)) {
      console.error(`\u274C Invalid status: ${newStatus}`);
      throw new Error(`Invalid status: ${newStatus}`);
    }
    console.log(`\u2705 Status validation passed: ${newStatus}`);
    const oldStatus = this.currentProject.status;
    this.currentProject.status = newStatus;
    this.currentProject.lastModified = new Date();
    console.log(`\u{1F4BE} Updated in-memory status from ${oldStatus} to ${newStatus}`);
    const dashboardPath = `${this.currentProject.rootPath}/_project.md`;
    const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
    console.log(`\u{1F4C1} Dashboard file path: ${dashboardPath}`);
    if (dashboardFile) {
      console.log(`\u{1F4D6} Reading dashboard file...`);
      const content = await this.app.vault.read(dashboardFile);
      console.log(`\u{1F4DD} Updating frontmatter field: status = ${newStatus}`);
      const updatedContent = this.updateFrontmatterField(content, "status", newStatus);
      console.log(`\u{1F4BE} Writing updated content to file...`);
      await this.app.vault.modify(dashboardFile, updatedContent);
      console.log(`\u2705 Dashboard file updated successfully`);
    } else {
      console.error(`\u274C Dashboard file not found: ${dashboardPath}`);
    }
    console.log(`\u{1F504} Triggering dashboard refresh...`);
    this.app.workspace.trigger("layout-change");
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.path.endsWith("/_project.md")) {
      setTimeout(() => {
        const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeLeaf) {
          console.log(`\u{1F504} Force rerendering active dashboard...`);
          activeLeaf.previewMode.rerender(true);
        }
      }, 50);
    }
    console.log(`\u2705 updateProjectStatus completed`);
  }
  /**
   * 更新frontmatter中的字段
   * Update field in frontmatter
   */
  updateFrontmatterField(content, field, value) {
    console.log(`\u{1F527} updateFrontmatterField called: ${field} = ${value}`);
    const lines = content.split("\n");
    let inFrontmatter = false;
    let frontmatterEnd = -1;
    let fieldFound = false;
    console.log(`\u{1F4C4} Processing ${lines.length} lines`);
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === "---") {
        if (!inFrontmatter) {
          inFrontmatter = true;
          console.log(`\u{1F4DD} Frontmatter start found at line ${i}`);
        } else {
          frontmatterEnd = i;
          console.log(`\u{1F4DD} Frontmatter end found at line ${i}`);
          break;
        }
      } else if (inFrontmatter && lines[i].startsWith(`${field}:`)) {
        console.log(`\u{1F50D} Found existing field at line ${i}: ${lines[i]}`);
        lines[i] = `${field}: "${value}"`;
        console.log(`\u270F\uFE0F Updated field to: ${lines[i]}`);
        fieldFound = true;
        const result2 = lines.join("\n");
        console.log(`\u2705 Field updated successfully`);
        return result2;
      }
    }
    if (!fieldFound && frontmatterEnd > 0) {
      console.log(`\u2795 Field not found, adding new field at line ${frontmatterEnd}`);
      lines.splice(frontmatterEnd, 0, `${field}: "${value}"`);
      console.log(`\u2705 New field added: ${field}: "${value}"`);
    } else if (!fieldFound) {
      console.error(`\u274C Could not add field: frontmatterEnd = ${frontmatterEnd}`);
    }
    const result = lines.join("\n");
    console.log(`\u{1F4CB} updateFrontmatterField completed`);
    return result;
  }
  /**
   * 导出项目
   * Export project with specified options
   */
  async exportProject(options) {
    if (!this.currentProject) {
      throw new Error("No project loaded");
    }
    console.log("Export project - to be implemented in later tasks", options);
  }
  /**
   * 初始化缓存
   * Initialize data cache by scanning project files
   */
  async initializeCache() {
    if (!this.currentProject) {
      throw new Error("No project loaded");
    }
    try {
      this.sceneCache.clear();
      this.characterCache.clear();
      this.locationCache.clear();
      await this.scanScenesFolder();
      await this.scanCharactersFolder();
      await this.scanLocationsFolder();
      this.cacheInitialized = true;
      console.log("Cache initialized successfully");
    } catch (error) {
      console.error("Failed to initialize cache:", error);
      throw error;
    }
  }
  /**
   * 扫描稿件文件夹
   * Scan scenes folder and populate scene cache
   */
  async scanScenesFolder() {
    var _a;
    const folderStructure = ((_a = this.settings) == null ? void 0 : _a.folderStructure) || { scenes: "10_\u7A3F\u4EF6" };
    const scenesPath = `${this.currentProject.rootPath}/${folderStructure.scenes}`;
    console.log(`Scanning scenes folder: ${scenesPath}`);
    const scenesFolder = this.app.vault.getAbstractFileByPath(scenesPath);
    if (!scenesFolder) {
      console.warn(`Scenes folder not found: ${scenesPath}`);
      return;
    }
    await this.scanFolderForScenes(scenesPath);
    console.log(`Scenes scan completed. Found ${this.sceneCache.size} scenes`);
  }
  /**
   * 递归扫描文件夹中的场景文件
   * Recursively scan folder for scene files
   */
  async scanFolderForScenes(folderPath) {
    const files = this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(folderPath) && file.extension === "md"
    );
    console.log(`Found ${files.length} markdown files in ${folderPath}`);
    for (const file of files) {
      console.log(`Processing scene file: ${file.path}`);
      await this.processSceneFile(file);
    }
  }
  /**
   * 处理场景文件
   * Process scene file and add to cache
   */
  async processSceneFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      const pathParts = file.path.split("/");
      const fileName = file.basename;
      const indexMatch = fileName.match(/^(\d+)-(\d+)/);
      const chapterIndex = indexMatch ? parseInt(indexMatch[1]) : 0;
      const sceneIndex = indexMatch ? parseInt(indexMatch[2]) : 0;
      let wordCount = (frontmatter == null ? void 0 : frontmatter.word_count) || 0;
      console.log(`Scene ${file.path}: frontmatter word_count = ${frontmatter == null ? void 0 : frontmatter.word_count}`);
      if (!(frontmatter == null ? void 0 : frontmatter.word_count)) {
        const content = await this.app.vault.read(file);
        wordCount = this.calculateWordCount(content, file.path);
        console.log(`Calculated word count for ${file.path}: ${wordCount}`);
        await this.updateSceneWordCountInFrontmatter(file, wordCount);
      }
      const sceneData = {
        path: file.path,
        title: (frontmatter == null ? void 0 : frontmatter.title) || file.basename,
        status: (frontmatter == null ? void 0 : frontmatter.status) || "outline",
        pov: (frontmatter == null ? void 0 : frontmatter.pov) || "",
        location: (frontmatter == null ? void 0 : frontmatter.location) || "",
        storyTime: (frontmatter == null ? void 0 : frontmatter.story_time) ? new Date(frontmatter.story_time) : null,
        synopsis: (frontmatter == null ? void 0 : frontmatter.synopsis) || "",
        wordCount,
        chapterIndex,
        sceneIndex,
        tags: (frontmatter == null ? void 0 : frontmatter.tags) || [],
        lastModified: new Date(file.stat.mtime)
      };
      this.sceneCache.set(file.path, sceneData);
    } catch (error) {
      console.error(`Failed to process scene file: ${file.path}`, error);
    }
  }
  /**
   * 扫描角色文件夹
   * Scan characters folder and populate character cache
   */
  async scanCharactersFolder() {
    var _a;
    const folderStructure = ((_a = this.settings) == null ? void 0 : _a.folderStructure) || { characters: "20_\u89D2\u8272" };
    const charactersPath = `${this.currentProject.rootPath}/${folderStructure.characters}`;
    const files = this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(charactersPath) && file.extension === "md"
    );
    for (const file of files) {
      await this.processCharacterFile(file);
    }
  }
  /**
   * 处理角色文件
   * Process character file and add to cache
   */
  async processCharacterFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      const characterData = {
        path: file.path,
        name: (frontmatter == null ? void 0 : frontmatter.name) || file.basename,
        faction: (frontmatter == null ? void 0 : frontmatter.faction) || "",
        status: (frontmatter == null ? void 0 : frontmatter.status) || "unknown",
        age: (frontmatter == null ? void 0 : frontmatter.age) || 0,
        description: (frontmatter == null ? void 0 : frontmatter.description) || "",
        goals: (frontmatter == null ? void 0 : frontmatter.goals) || "",
        relationships: (frontmatter == null ? void 0 : frontmatter.relationships) || [],
        appearances: (frontmatter == null ? void 0 : frontmatter.appearances) || []
      };
      this.characterCache.set(file.path, characterData);
    } catch (error) {
      console.error(`Failed to process character file: ${file.path}`, error);
    }
  }
  /**
   * 扫描地点文件夹
   * Scan locations folder and populate location cache
   */
  async scanLocationsFolder() {
    var _a;
    const folderStructure = ((_a = this.settings) == null ? void 0 : _a.folderStructure) || { locations: "30_\u5730\u70B9" };
    const locationsPath = `${this.currentProject.rootPath}/${folderStructure.locations}`;
    const files = this.app.vault.getFiles().filter(
      (file) => file.path.startsWith(locationsPath) && file.extension === "md"
    );
    for (const file of files) {
      await this.processLocationFile(file);
    }
  }
  /**
   * 处理地点文件
   * Process location file and add to cache
   */
  async processLocationFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      const locationData = {
        path: file.path,
        name: (frontmatter == null ? void 0 : frontmatter.name) || file.basename,
        region: (frontmatter == null ? void 0 : frontmatter.region) || "",
        description: (frontmatter == null ? void 0 : frontmatter.description) || "",
        significance: (frontmatter == null ? void 0 : frontmatter.significance) || "",
        connectedLocations: (frontmatter == null ? void 0 : frontmatter.connected_locations) || [],
        scenes: (frontmatter == null ? void 0 : frontmatter.scenes) || []
      };
      this.locationCache.set(file.path, locationData);
    } catch (error) {
      console.error(`Failed to process location file: ${file.path}`, error);
    }
  }
  /**
   * 创建项目文件夹结构
   * Create project folder structure
   */
  async createProjectStructure(projectPath) {
    var _a;
    const folderStructure = ((_a = this.settings) == null ? void 0 : _a.folderStructure) || {
      scenes: "10_\u7A3F\u4EF6",
      characters: "20_\u89D2\u8272",
      locations: "30_\u5730\u70B9",
      settings: "40_\u8BBE\u5B9A",
      templates: "80_\u6A21\u677F",
      trash: "90_\u56DE\u6536\u7AD9"
    };
    const allFolders = [
      projectPath,
      // 主项目文件夹
      `${projectPath}/${folderStructure.scenes}`,
      `${projectPath}/${folderStructure.scenes}/\u7B2C\u4E00\u5377`,
      `${projectPath}/${folderStructure.scenes}/\u7B2C\u4E00\u5377/\u7B2C\u4E00\u7AE0`,
      `${projectPath}/${folderStructure.characters}`,
      `${projectPath}/${folderStructure.locations}`,
      `${projectPath}/${folderStructure.settings}`,
      `${projectPath}/${folderStructure.templates}`,
      `${projectPath}/90_\u56DE\u6536\u7AD9`
    ];
    const folderPromises = allFolders.map(async (folderPath) => {
      var _a2;
      try {
        await this.app.vault.createFolder(folderPath);
      } catch (error) {
        if (!((_a2 = error.message) == null ? void 0 : _a2.includes("already exists"))) {
          console.warn(`Failed to create folder: ${folderPath}`, error);
        }
      }
    });
    await Promise.all(folderPromises);
    await Promise.all([
      this.createDefaultTemplates(projectPath),
      this.createExampleFiles(projectPath)
    ]);
  }
  /**
   * 创建默认模板文件
   * Create default template files
   */
  async createDefaultTemplates(projectPath) {
    const templatePath = `${projectPath}/80_\u6A21\u677F`;
    const characterTemplate = `---
tags: [character]
faction: ""
status: "alive"
age: 0
goals: ""
relationships: []
appearances: []
---

# {{title}}

## \u57FA\u672C\u4FE1\u606F

- **\u59D3\u540D**: {{title}}
- **\u5E74\u9F84**: 
- **\u6027\u522B**: 
- **\u804C\u4E1A**: 
- **\u6240\u5C5E\u9635\u8425**: 

## \u5916\u8C8C\u63CF\u8FF0



## \u6027\u683C\u7279\u5F81



## \u80CC\u666F\u6545\u4E8B



## \u89D2\u8272\u76EE\u6807



## \u4EBA\u9645\u5173\u7CFB



## \u91CD\u8981\u4E8B\u4EF6

`;
    const locationTemplate = `---
tags: [location]
region: ""
significance: ""
connected_locations: []
scenes: []
---

# {{title}}

## \u57FA\u672C\u4FE1\u606F

- **\u5730\u70B9\u540D\u79F0**: {{title}}
- **\u6240\u5C5E\u533A\u57DF**: 
- **\u91CD\u8981\u7A0B\u5EA6**: 

## \u5730\u70B9\u63CF\u8FF0



## \u5730\u7406\u4F4D\u7F6E



## \u5386\u53F2\u80CC\u666F



## \u76F8\u5173\u89D2\u8272



## \u53D1\u751F\u7684\u91CD\u8981\u4E8B\u4EF6

`;
    const sceneTemplate = `---
tags: [scene]
status: "outline"
pov: ""
location: ""
story_time: ""
synopsis: ""
word_count: 0
chapter_index: 1
scene_index: 1
---

# {{title}}

## \u573A\u666F\u6897\u6982



## \u573A\u666F\u5185\u5BB9

`;
    const templates = {
      "\u89D2\u8272\u6A21\u677F.md": characterTemplate,
      "\u5730\u70B9\u6A21\u677F.md": locationTemplate,
      "\u573A\u666F\u6A21\u677F.md": sceneTemplate
    };
    const templatePromises = Object.entries(templates).map(async ([filename, content]) => {
      var _a;
      try {
        await this.app.vault.create(`${templatePath}/${filename}`, content);
      } catch (error) {
        if (!((_a = error.message) == null ? void 0 : _a.includes("already exists"))) {
          console.warn(`Failed to create template: ${filename}`, error);
        }
      }
    });
    await Promise.all(templatePromises);
  }
  /**
   * 创建示例文件
   * Create example files to help users get started
   */
  async createExampleFiles(projectPath) {
    const chapterPath = `${projectPath}/10_\u7A3F\u4EF6/\u7B2C\u4E00\u5377/\u7B2C\u4E00\u7AE0`;
    const exampleFiles = {
      [`${chapterPath}/01-01 \u5F00\u573A.md`]: `---
tags: [scene]
status: "outline"
pov: ""
location: ""
story_time: ""
synopsis: "\u6545\u4E8B\u7684\u5F00\u59CB"
word_count: 0
chapter_index: 1
scene_index: 1
---

# 01-01 \u5F00\u573A

## \u573A\u666F\u6897\u6982

\u8FD9\u662F\u60A8\u6545\u4E8B\u7684\u7B2C\u4E00\u4E2A\u573A\u666F\u3002\u5728\u8FD9\u91CC\u63CF\u8FF0\u573A\u666F\u7684\u4E3B\u8981\u5185\u5BB9\u548C\u76EE\u7684\u3002

## \u573A\u666F\u5185\u5BB9

\u5F00\u59CB\u60A8\u7684\u521B\u4F5C\u5427...
`,
      [`${projectPath}/README.md`]: `# \u7EC7\u6587\u8005\u9879\u76EE\u4F7F\u7528\u8BF4\u660E

\u6B22\u8FCE\u4F7F\u7528\u7EC7\u6587\u8005\u63D2\u4EF6\uFF01\u8FD9\u4E2A\u9879\u76EE\u5DF2\u7ECF\u4E3A\u60A8\u8BBE\u7F6E\u597D\u4E86\u6807\u51C6\u7684\u5C0F\u8BF4\u521B\u4F5C\u7ED3\u6784\u3002

## \u6587\u4EF6\u5939\u8BF4\u660E

- **10_\u7A3F\u4EF6**: \u5B58\u653E\u60A8\u7684\u5C0F\u8BF4\u7AE0\u8282\u548C\u573A\u666F
- **20_\u89D2\u8272**: \u89D2\u8272\u8BBE\u5B9A\u548C\u4EBA\u7269\u6863\u6848
- **30_\u5730\u70B9**: \u5730\u70B9\u8BBE\u5B9A\u548C\u573A\u666F\u63CF\u8FF0  
- **40_\u8BBE\u5B9A**: \u4E16\u754C\u89C2\u548C\u80CC\u666F\u8BBE\u5B9A
- **80_\u6A21\u677F**: \u81EA\u5B9A\u4E49\u6A21\u677F\u6587\u4EF6
- **90_\u56DE\u6536\u7AD9**: \u5DF2\u5220\u9664\u5185\u5BB9\u7684\u5907\u4EFD

## \u5FEB\u901F\u5F00\u59CB

1. \u5728 **10_\u7A3F\u4EF6** \u6587\u4EF6\u5939\u4E2D\u521B\u5EFA\u60A8\u7684\u7AE0\u8282\u7ED3\u6784
2. \u5728 **20_\u89D2\u8272** \u6587\u4EF6\u5939\u4E2D\u6DFB\u52A0\u89D2\u8272\u6863\u6848
3. \u5728 **30_\u5730\u70B9** \u6587\u4EF6\u5939\u4E2D\u6DFB\u52A0\u5730\u70B9\u8BBE\u5B9A
4. \u4F7F\u7528\u547D\u4EE4\u9762\u677F\u4E2D\u7684"\u7EC7\u6587\u8005"\u76F8\u5173\u547D\u4EE4\u6765\u7BA1\u7406\u60A8\u7684\u9879\u76EE

## \u6587\u4EF6\u547D\u540D\u5EFA\u8BAE

- \u573A\u666F\u6587\u4EF6: \`01-01 \u573A\u666F\u6807\u9898.md\` (\u7AE0\u8282-\u573A\u666F \u6807\u9898)
- \u89D2\u8272\u6587\u4EF6: \`\u89D2\u8272\u540D.md\`
- \u5730\u70B9\u6587\u4EF6: \`\u5730\u70B9\u540D.md\`

\u795D\u60A8\u521B\u4F5C\u6109\u5FEB\uFF01
`
    };
    const filePromises = Object.entries(exampleFiles).map(async ([filePath, content]) => {
      var _a;
      try {
        await this.app.vault.create(filePath, content);
      } catch (error) {
        if (!((_a = error.message) == null ? void 0 : _a.includes("already exists"))) {
          console.warn(`Failed to create example file: ${filePath}`, error);
        }
      }
    });
    await Promise.all(filePromises);
  }
  /**
   * 创建项目仪表盘文件
   * Create project dashboard file
   */
  async createProjectDashboard(name, path) {
    const dashboardPath = `${path}/_project.md`;
    const dashboardContent = `---
name: "${name}"
target_word_count: 100000
current_word_count: 0
created_date: ${this.getUTC8TimeString()}
synopsis: ""
status: "planning"
template_path: "${path}/80_\u6A21\u677F"
auto_save_interval: 30
enable_word_count: true
enable_timeline: true
tags: [project, story-weaver]
---

# ${name}

## \u9879\u76EE\u6982\u89C8

\u8FD9\u662F\u60A8\u7684\u5199\u4F5C\u9879\u76EE\u4EEA\u8868\u76D8\u3002\u7EDF\u8BA1\u4FE1\u606F\u901A\u8FC7 Dataview \u81EA\u52A8\u66F4\u65B0\uFF0C\u65E0\u9700\u624B\u52A8\u5237\u65B0\u3002

## \u{1F4CA} \u5199\u4F5C\u7EDF\u8BA1

### \u573A\u666F\u72B6\u6001\u5206\u5E03
\`\`\`dataview
TABLE WITHOUT ID
  choice(status = "outline", "\u{1F4DD}", choice(status = "draft", "\u270F\uFE0F", choice(status = "revised", "\u{1F4D6}", choice(status = "complete", "\u2705", "\u2753")))) + " " + status as "\u72B6\u6001",
  length(rows) as "\u6570\u91CF"
FROM "${path}/10_\u7A3F\u4EF6"
WHERE tags AND contains(tags, "scene")
GROUP BY status
SORT status
\`\`\`

### \u7AE0\u8282\u5B57\u6570\u7EDF\u8BA1
\`\`\`dataview
TABLE WITHOUT ID
  chapter_index as "\u7AE0\u8282",
  length(rows) as "\u573A\u666F\u6570",
  sum(rows.word_count) as "\u5B57\u6570"
FROM "${path}/10_\u7A3F\u4EF6"
WHERE tags AND contains(tags, "scene") AND chapter_index
GROUP BY chapter_index
SORT chapter_index
\`\`\`

## \u{1F4DA} \u89D2\u8272\u7BA1\u7406

### \u89D2\u8272\u5217\u8868
\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, file.name) as "\u89D2\u8272",
  status as "\u72B6\u6001",
  age as "\u5E74\u9F84",
  faction as "\u9635\u8425"
FROM "${path}/20_\u89D2\u8272"
WHERE tags AND contains(tags, "character")
SORT file.name
\`\`\`

## \u{1F5FA}\uFE0F \u5730\u70B9\u7BA1\u7406

### \u5730\u70B9\u5217\u8868
\`\`\`dataview
TABLE WITHOUT ID
  link(file.link, file.name) as "\u5730\u70B9",
  region as "\u533A\u57DF",
  significance as "\u91CD\u8981\u7A0B\u5EA6"
FROM "${path}/30_\u5730\u70B9"
WHERE tags AND contains(tags, "location")
SORT file.name
\`\`\`

## \u{1F4C8} \u5199\u4F5C\u8FDB\u5EA6

### \u6BCF\u65E5\u5199\u4F5C\u76EE\u6807
- **\u65E5\u5747\u76EE\u6807**: {{DAILY_TARGET}} \u5B57
- **\u4ECA\u65E5\u603B\u5B57\u6570**: {{TODAY_WORDS}} \u5B57
- **\u5269\u4F59\u5B57\u6570**: {{REMAINING_WORDS}} \u5B57

### \u9879\u76EE\u72B6\u6001
**\u5F53\u524D\u72B6\u6001**: {{PROJECT_STATUS}}

{{PROJECT_STATUS_SWITCHER}}

## \u{1F4DD} \u9879\u76EE\u7B14\u8BB0

\u5728\u8FD9\u91CC\u8BB0\u5F55\u60A8\u7684\u521B\u4F5C\u60F3\u6CD5\u548C\u9879\u76EE\u8FDB\u5C55...

---

> \u{1F4A1} **\u63D0\u793A**: \u6B64\u4EEA\u8868\u76D8\u4F7F\u7528 Dataview \u63D2\u4EF6\u81EA\u52A8\u7EDF\u8BA1\u6570\u636E\u3002\u5982\u679C\u7EDF\u8BA1\u4FE1\u606F\u672A\u663E\u793A\uFF0C\u8BF7\u786E\u4FDD\u5DF2\u5B89\u88C5\u5E76\u542F\u7528 Dataview \u63D2\u4EF6\u3002
`;
    await this.app.vault.create(dashboardPath, dashboardContent);
  }
  /**
   * 计算总字数
   * Calculate total word count
   */
  calculateTotalWords() {
    let totalWords = 0;
    for (const scene of this.sceneCache.values()) {
      totalWords += scene.wordCount || 0;
    }
    return totalWords;
  }
  /**
   * 计算今日新增字数
   * Calculate today's word count
   */
  calculateTodayWords() {
    try {
      const today = new Date();
      const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      let todayWords = 0;
      for (const scene of this.sceneCache.values()) {
        const fileModTime = new Date(scene.lastModified);
        if (fileModTime >= todayStart) {
          todayWords += scene.wordCount || 0;
        }
      }
      if (todayWords === 0) {
        const totalWords = this.calculateTotalWords();
        if (totalWords > 0) {
          const daysSinceCreation = this.currentProject ? Math.max(1, Math.ceil((Date.now() - this.currentProject.createdDate.getTime()) / (1e3 * 60 * 60 * 24))) : 1;
          todayWords = Math.floor(totalWords / daysSinceCreation);
        }
      }
      return Math.max(0, todayWords);
    } catch (error) {
      console.error("Failed to calculate today words:", error);
      return 0;
    }
  }
  /**
   * 计算章节数量
   * Calculate chapter count
   */
  calculateChapterCount() {
    const chapters = /* @__PURE__ */ new Set();
    for (const scene of this.sceneCache.values()) {
      chapters.add(scene.chapterIndex);
    }
    return chapters.size;
  }
  /**
   * 解析文件的 YAML frontmatter
   * Parse YAML frontmatter from file content
   */
  parseFrontmatter(content) {
    try {
      if (!content.startsWith("---\n")) {
        return null;
      }
      const endIndex = content.indexOf("\n---\n", 4);
      if (endIndex === -1) {
        return null;
      }
      const yamlContent = content.substring(4, endIndex);
      const frontmatter = {};
      const lines = yamlContent.split("\n");
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (!trimmedLine || trimmedLine.startsWith("#")) {
          continue;
        }
        const colonIndex = trimmedLine.indexOf(":");
        if (colonIndex === -1) {
          continue;
        }
        const key = trimmedLine.substring(0, colonIndex).trim();
        let value = trimmedLine.substring(colonIndex + 1).trim();
        if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
          value = value.slice(1, -1);
        }
        if (value === "true") {
          frontmatter[key] = true;
        } else if (value === "false") {
          frontmatter[key] = false;
        } else if (!isNaN(Number(value)) && value !== "") {
          frontmatter[key] = Number(value);
        } else if (value.startsWith("[") && value.endsWith("]")) {
          const arrayContent = value.slice(1, -1);
          frontmatter[key] = arrayContent.split(",").map((item) => item.trim());
        } else {
          frontmatter[key] = value;
        }
      }
      return frontmatter;
    } catch (error) {
      console.error("Failed to parse frontmatter:", error);
      return null;
    }
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  cleanup() {
    this.disableFileSystemListener();
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer);
    }
    this.debounceTimers.clear();
    this.sceneCache.clear();
    this.characterCache.clear();
    this.locationCache.clear();
    this.currentProject = null;
    this.cacheInitialized = false;
  }
  /**
   * 防抖执行函数
   * Debounced execution function
   */
  debounce(key, fn, delay = 300) {
    const existingTimer = this.debounceTimers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const timer = setTimeout(() => {
      fn();
      this.debounceTimers.delete(key);
    }, delay);
    this.debounceTimers.set(key, timer);
  }
  /**
   * 检查缓存是否已初始化
   * Check if cache is initialized
   */
  isCacheInitialized() {
    return this.cacheInitialized;
  }
  /**
   * 获取场景数据
   * Get scene data by path
   */
  getSceneData(path) {
    return this.sceneCache.get(path);
  }
  /**
   * 获取角色数据
   * Get character data by path
   */
  getCharacterData(path) {
    return this.characterCache.get(path);
  }
  /**
   * 获取地点数据
   * Get location data by path
   */
  getLocationData(path) {
    return this.locationCache.get(path);
  }
  /**
   * 获取所有场景数据
   * Get all scene data
   */
  getAllScenes() {
    return Array.from(this.sceneCache.values());
  }
  /**
   * 获取所有角色数据
   * Get all character data
   */
  getAllCharacters() {
    return Array.from(this.characterCache.values());
  }
  /**
   * 获取所有地点数据
   * Get all location data
   */
  getAllLocations() {
    return Array.from(this.locationCache.values());
  }
  /**
   * 启用文件系统监听
   * Enable file system monitoring
   */
  enableFileSystemListener() {
    if (this.fileSystemListenerEnabled) {
      return;
    }
    const metadataChangeRef = this.app.metadataCache.on("changed", (file) => {
      this.debounce(`metadata-${file.path}`, () => {
        this.handleMetadataChange(file);
      }, 300);
    });
    const fileCreateRef = this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.debounce(`create-${file.path}`, () => {
          this.handleFileCreate(file);
        }, 100);
      }
    });
    const fileDeleteRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.handleFileDelete(file);
      }
    });
    const fileRenameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.debounce(`rename-${file.path}`, () => {
          this.handleFileRename(file, oldPath);
        }, 100);
      }
    });
    const fileModifyRef = this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        this.debounce(`modify-${file.path}`, () => {
          this.handleFileModify(file);
        }, 1e3);
      }
    });
    this.eventRefs.push(metadataChangeRef, fileCreateRef, fileDeleteRef, fileRenameRef, fileModifyRef);
    this.fileSystemListenerEnabled = true;
    console.log("File system listener enabled");
  }
  /**
   * 禁用文件系统监听
   * Disable file system monitoring
   */
  disableFileSystemListener() {
    if (!this.fileSystemListenerEnabled) {
      return;
    }
    this.eventRefs.forEach((ref) => {
      this.app.metadataCache.offref(ref);
      this.app.vault.offref(ref);
    });
    this.eventRefs = [];
    this.fileSystemListenerEnabled = false;
    console.log("File system listener disabled");
  }
  /**
   * 处理元数据变化事件
   * Handle metadata change event
   */
  async handleMetadataChange(file) {
    if (!this.currentProject || !this.isProjectFile(file.path)) {
      return;
    }
    try {
      const fileType = this.getFileType(file.path);
      switch (fileType) {
        case "scene":
          await this.updateSceneCache(file);
          break;
        case "character":
          await this.updateCharacterCache(file);
          break;
        case "location":
          await this.updateLocationCache(file);
          break;
        case "project":
          await this.updateProjectData(file);
          break;
      }
      console.log(`Cache updated for file: ${file.path}`);
    } catch (error) {
      console.error(`Failed to handle metadata change for ${file.path}:`, error);
    }
  }
  /**
   * 处理文件创建事件
   * Handle file create event
   */
  async handleFileCreate(file) {
    if (!this.currentProject || !this.isProjectFile(file.path)) {
      return;
    }
    try {
      const fileType = this.getFileType(file.path);
      switch (fileType) {
        case "scene":
          await this.processSceneFile(file);
          break;
        case "character":
          await this.processCharacterFile(file);
          break;
        case "location":
          await this.processLocationFile(file);
          break;
      }
      console.log(`File added to cache: ${file.path}`);
    } catch (error) {
      console.error(`Failed to handle file creation for ${file.path}:`, error);
    }
  }
  /**
   * 处理文件删除事件
   * Handle file delete event
   */
  handleFileDelete(file) {
    if (!this.currentProject || !this.isProjectFile(file.path)) {
      return;
    }
    try {
      const fileType = this.getFileType(file.path);
      switch (fileType) {
        case "scene":
          this.sceneCache.delete(file.path);
          break;
        case "character":
          this.characterCache.delete(file.path);
          break;
        case "location":
          this.locationCache.delete(file.path);
          break;
      }
      console.log(`File removed from cache: ${file.path}`);
    } catch (error) {
      console.error(`Failed to handle file deletion for ${file.path}:`, error);
    }
  }
  /**
   * 处理文件重命名事件
   * Handle file rename event
   */
  async handleFileRename(file, oldPath) {
    if (!this.currentProject) {
      return;
    }
    try {
      if (this.isProjectFile(oldPath)) {
        const oldFileType = this.getFileType(oldPath);
        switch (oldFileType) {
          case "scene":
            this.sceneCache.delete(oldPath);
            break;
          case "character":
            this.characterCache.delete(oldPath);
            break;
          case "location":
            this.locationCache.delete(oldPath);
            break;
        }
      }
      if (this.isProjectFile(file.path)) {
        const newFileType = this.getFileType(file.path);
        switch (newFileType) {
          case "scene":
            await this.processSceneFile(file);
            break;
          case "character":
            await this.processCharacterFile(file);
            break;
          case "location":
            await this.processLocationFile(file);
            break;
        }
      }
      console.log(`File renamed in cache: ${oldPath} -> ${file.path}`);
    } catch (error) {
      console.error(`Failed to handle file rename from ${oldPath} to ${file.path}:`, error);
    }
  }
  /**
   * 处理文件修改事件
   * Handle file modify event
   */
  async handleFileModify(file) {
    if (!this.currentProject || !this.isProjectFile(file.path)) {
      return;
    }
    try {
      const fileType = this.getFileType(file.path);
      if (fileType === "scene") {
        await this.updateSceneWordCountAndCache(file);
      }
      console.log(`File content updated: ${file.path}`);
    } catch (error) {
      console.error(`Failed to handle file modify for ${file.path}:`, error);
    }
  }
  /**
   * 更新场景字数统计并更新缓存
   * Update scene word count and cache
   */
  async updateSceneWordCountAndCache(file) {
    try {
      const content = await this.app.vault.read(file);
      const wordCount = this.calculateWordCount(content, file.path);
      const scene = this.sceneCache.get(file.path);
      if (scene) {
        scene.wordCount = wordCount;
        scene.lastModified = new Date();
        this.sceneCache.set(file.path, scene);
      }
      await this.updateSceneWordCountInFrontmatter(file, wordCount);
      await this.updateProjectCurrentWordCount();
    } catch (error) {
      console.error(`Failed to update word count for scene: ${file.path}`, error);
    }
  }
  /**
   * 更新项目当前字数
   * Update project current word count
   */
  async updateProjectCurrentWordCount() {
    if (!this.currentProject) {
      return;
    }
    try {
      const totalWords = this.calculateTotalWords();
      this.currentProject.currentWordCount = totalWords;
      const dashboardPath = `${this.currentProject.rootPath}/_project.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile) {
        await this.app.fileManager.processFrontMatter(dashboardFile, (frontmatter) => {
          frontmatter.current_word_count = totalWords;
          frontmatter.last_updated = this.getUTC8TimeString();
        });
      }
    } catch (error) {
      console.error("Failed to update project current word count:", error);
    }
  }
  /**
   * 获取东八区时间字符串
   * Get UTC+8 timezone formatted date string
   */
  getUTC8TimeString() {
    const now = new Date();
    const utc8Time = new Date(now.getTime() + 8 * 60 * 60 * 1e3);
    return utc8Time.toISOString().replace("Z", "+08:00");
  }
  /**
   * 更新场景文件 frontmatter 中的字数统计
   * Update word count in scene file frontmatter
   */
  async updateSceneWordCountInFrontmatter(file, wordCount) {
    try {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter.word_count = wordCount;
        frontmatter.last_updated = this.getUTC8TimeString();
      });
    } catch (error) {
      console.error(`Failed to update frontmatter for ${file.path}:`, error);
    }
  }
  /**
   * 更新场景缓存
   * Update scene cache for specific file
   */
  async updateSceneCache(file) {
    await this.processSceneFile(file);
  }
  /**
   * 更新角色缓存
   * Update character cache for specific file
   */
  async updateCharacterCache(file) {
    await this.processCharacterFile(file);
  }
  /**
   * 更新地点缓存
   * Update location cache for specific file
   */
  async updateLocationCache(file) {
    await this.processLocationFile(file);
  }
  /**
   * 更新项目数据
   * Update project data from dashboard file
   */
  async updateProjectData(file) {
    if (!this.currentProject || file.path !== `${this.currentProject.rootPath}/_project.md`) {
      return;
    }
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = metadata == null ? void 0 : metadata.frontmatter;
      if (frontmatter) {
        this.currentProject.name = frontmatter.name || this.currentProject.name;
        this.currentProject.targetWordCount = frontmatter.target_word_count || this.currentProject.targetWordCount;
        this.currentProject.currentWordCount = frontmatter.current_word_count || this.currentProject.currentWordCount;
        this.currentProject.synopsis = frontmatter.synopsis || this.currentProject.synopsis;
        this.currentProject.lastModified = new Date(file.stat.mtime);
        this.currentProject.settings.templatePath = frontmatter.template_path || this.currentProject.settings.templatePath;
        this.currentProject.settings.autoSaveInterval = frontmatter.auto_save_interval || this.currentProject.settings.autoSaveInterval;
        this.currentProject.settings.enableWordCount = frontmatter.enable_word_count !== false;
        this.currentProject.settings.enableTimeline = frontmatter.enable_timeline !== false;
        console.log("Project data updated from dashboard");
      }
    } catch (error) {
      console.error("Failed to update project data:", error);
    }
  }
  /**
   * 判断文件是否属于当前项目
   * Check if file belongs to current project
   */
  isProjectFile(filePath) {
    if (!this.currentProject) {
      return false;
    }
    return filePath.startsWith(this.currentProject.rootPath);
  }
  /**
   * 获取文件类型
   * Get file type based on path
   */
  getFileType(filePath) {
    if (!this.currentProject) {
      return "other";
    }
    const rootPath = this.currentProject.rootPath;
    if (filePath === `${rootPath}/_project.md`) {
      return "project";
    } else if (filePath.startsWith(`${rootPath}/10_\u7A3F\u4EF6/`)) {
      return "scene";
    } else if (filePath.startsWith(`${rootPath}/20_\u89D2\u8272/`)) {
      return "character";
    } else if (filePath.startsWith(`${rootPath}/30_\u5730\u70B9/`)) {
      return "location";
    }
    return "other";
  }
  /**
   * 强制刷新缓存
   * Force refresh cache (fallback for error recovery)
   */
  async forceRefreshCache() {
    if (!this.currentProject) {
      throw new Error("No project loaded");
    }
    console.log("Force refreshing cache...");
    await this.initializeCache();
    console.log("Cache force refresh completed");
  }
  /**
   * 获取缓存统计信息
   * Get cache statistics for debugging
   */
  getCacheStats() {
    return {
      scenes: this.sceneCache.size,
      characters: this.characterCache.size,
      locations: this.locationCache.size,
      listenerEnabled: this.fileSystemListenerEnabled
    };
  }
  /**
   * 获取元数据管理器实例
   * Get MetadataManager instance
   */
  getMetadataManager() {
    return this.metadataManager;
  }
  /**
   * 卸载当前项目
   * Unload current project and clean up resources
   */
  async unloadCurrentProject() {
    if (!this.currentProject) {
      return;
    }
    try {
      this.disableFileSystemListener();
      this.sceneCache.clear();
      this.characterCache.clear();
      this.locationCache.clear();
      this.currentProject = null;
      this.cacheInitialized = false;
      console.log("Current project unloaded successfully");
    } catch (error) {
      console.error("Failed to unload current project:", error);
    }
  }
  /**
   * 自动检测并加载项目
   * Auto-detect and load project from current context
   */
  async autoLoadProject(filePath) {
    try {
      let targetProjectPath = null;
      if (filePath) {
        targetProjectPath = this.detectProjectPath(filePath);
      }
      if (!targetProjectPath) {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          targetProjectPath = this.detectProjectPath(activeFile.path);
        }
      }
      if (!targetProjectPath) {
        return false;
      }
      if (this.currentProject && this.currentProject.rootPath === targetProjectPath) {
        return true;
      }
      console.log(`Switching to project: ${targetProjectPath}`);
      await this.loadProject(targetProjectPath);
      return true;
    } catch (error) {
      console.error("Failed to auto-load project:", error);
      return false;
    }
  }
  /**
   * 从文件路径检测项目根路径
   * Detect project root path from file path
   */
  detectProjectPath(filePath) {
    const pathParts = filePath.split("/");
    for (let i = pathParts.length - 1; i >= 0; i--) {
      const potentialProjectPath = pathParts.slice(0, i + 1).join("/");
      const dashboardPath = `${potentialProjectPath}/_project.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile) {
        return potentialProjectPath;
      }
    }
    return null;
  }
  /**
   * 检查指定路径是否是项目根路径
   * Check if the specified path is a project root
   */
  isProjectRoot(path) {
    const dashboardPath = `${path}/_project.md`;
    const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
    return !!dashboardFile;
  }
  /**
   * 更新场景字数统计
   * Update scene word count
   */
  async updateSceneWordCount(scenePath) {
    const file = this.app.vault.getAbstractFileByPath(scenePath);
    if (file instanceof import_obsidian.TFile) {
      const content = await this.app.vault.read(file);
      const wordCount = this.calculateWordCount(content, file.path);
      const scene = this.sceneCache.get(scenePath);
      if (scene) {
        scene.wordCount = wordCount;
        this.sceneCache.set(scenePath, scene);
      }
    }
  }
  /**
   * 使用 Obsidian 的方式计算字数
   * Calculate word count using Obsidian's method
   */
  calculateWordCount(content, filePath) {
    try {
      if (filePath) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView && activeView.file && activeView.file.path === filePath) {
          const editor = activeView.editor;
          if (editor) {
            const editorContent = editor.getValue();
            return this.calculateWordCountFromText(editorContent);
          }
        }
      }
    } catch (error) {
      console.debug("Failed to get editor word count, falling back to text calculation");
    }
    return this.calculateWordCountFromText(content);
  }
  /**
   * 从文本计算字数（改进版本）
   * Calculate word count from text (improved version)
   */
  calculateWordCountFromText(content) {
    const withoutFrontmatter = content.replace(/^---[\s\S]*?---\n?/, "");
    const withoutCodeBlocks = withoutFrontmatter.replace(/```[\s\S]*?```/g, "");
    const withoutInlineCode = withoutCodeBlocks.replace(/`[^`]*`/g, "");
    const withoutLinks = withoutInlineCode.replace(/\[([^\]]*)\]\([^)]*\)/g, "$1");
    const withoutImages = withoutLinks.replace(/!\[([^\]]*)\]\([^)]*\)/g, "");
    const withoutMarkdown = withoutImages.replace(/^#{1,6}\s+/gm, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/~~([^~]+)~~/g, "$1").replace(/==([^=]+)==/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^\s*>\s+/gm, "").replace(/---+/g, "").replace(/\|/g, " ");
    const cleanText = withoutMarkdown.replace(/\s+/g, " ").trim();
    if (!cleanText) {
      return 0;
    }
    const chineseChars = cleanText.match(/[\u4e00-\u9fff]/g);
    const englishWords = cleanText.match(/[a-zA-Z]+/g);
    const chineseCount = chineseChars ? chineseChars.length : 0;
    const englishCount = englishWords ? englishWords.length : 0;
    return chineseCount + englishCount;
  }
  /**
   * 从缓存中移除文件
   * Remove file from cache
   */
  removeFromCache(path) {
    this.sceneCache.delete(path);
    this.characterCache.delete(path);
    this.locationCache.delete(path);
  }
  /**
   * 清空所有缓存
   * Clear all caches
   */
  clearCache() {
    this.sceneCache.clear();
    this.characterCache.clear();
    this.locationCache.clear();
    this.cacheInitialized = false;
  }
  /**
   * 重建缓存
   * Rebuild cache from file system
   */
  async rebuildCache() {
    try {
      if (!this.currentProject) {
        throw new Error("No project loaded");
      }
      const processedFiles = [];
      await this.initializeCache();
      processedFiles.push(...Array.from(this.sceneCache.keys()));
      processedFiles.push(...Array.from(this.characterCache.keys()));
      processedFiles.push(...Array.from(this.locationCache.keys()));
      return {
        success: true,
        processedFiles
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
  /**
   * 加载文件到缓存
   * Load file to cache
   */
  async loadFileToCache(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      throw new Error(`File not found: ${path}`);
    }
    const fileType = this.getFileType(path);
    switch (fileType) {
      case "scene":
        await this.processSceneFile(file);
        break;
      case "character":
        await this.processCharacterFile(file);
        break;
      case "location":
        await this.processLocationFile(file);
        break;
      default:
        throw new Error(`Unsupported file type for path: ${path}`);
    }
  }
  /**
   * 获取 App 实例
   * Get App instance
   */
  getApp() {
    return this.app;
  }
};
var ProjectService = _ProjectService;
ProjectService.instance = null;

// src/services/TemplateService.ts
var TemplateService = class {
  constructor(app) {
    this.settings = null;
    this.app = app;
    this.projectService = ProjectService.getInstance(app);
  }
  /**
   * 更新设置
   * Update settings
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * 检测文件类型并应用对应模板
   * Detect file type and apply corresponding template
   */
  async applyTemplateToNewFile(file) {
    try {
      if (!this.projectService.currentProject) {
        return { success: false, templateType: null, error: "No project loaded" };
      }
      const templateType = this.detectFileType(file.path);
      if (!templateType) {
        return { success: false, templateType: null, error: "File not in template-applicable folder" };
      }
      const content = await this.app.vault.read(file);
      if (content.trim() && !this.isDefaultContent(content)) {
        return { success: false, templateType, error: "File already has content" };
      }
      const templateContent = await this.getTemplateContent(templateType);
      if (!templateContent) {
        return { success: false, templateType, error: `Template not found for type: ${templateType}` };
      }
      const processedContent = this.processTemplate(templateContent, file);
      await this.app.vault.modify(file, processedContent);
      console.log(`Template applied successfully: ${templateType} template to ${file.path}`);
      return { success: true, templateType };
    } catch (error) {
      console.error("Failed to apply template:", error);
      return {
        success: false,
        templateType: null,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * 检测文件类型
   * Detect file type based on path
   */
  detectFileType(filePath) {
    var _a;
    if (!this.projectService.currentProject) {
      return null;
    }
    const projectRoot = this.projectService.currentProject.rootPath;
    const folderStructure = ((_a = this.settings) == null ? void 0 : _a.folderStructure) || {
      scenes: "10_\u7A3F\u4EF6",
      characters: "20_\u89D2\u8272",
      locations: "30_\u5730\u70B9",
      settings: "40_\u8BBE\u5B9A",
      templates: "80_\u6A21\u677F",
      trash: "90_\u56DE\u6536\u7AD9"
    };
    if (filePath.startsWith(`${projectRoot}/${folderStructure.characters}/`)) {
      return "character";
    }
    if (filePath.startsWith(`${projectRoot}/${folderStructure.locations}/`)) {
      return "location";
    }
    if (filePath.startsWith(`${projectRoot}/${folderStructure.scenes}/`)) {
      return "scene";
    }
    return null;
  }
  /**
   * 获取模板内容
   * Get template content from template folder
   */
  async getTemplateContent(templateType) {
    if (!this.projectService.currentProject) {
      return null;
    }
    const templatePath = this.projectService.currentProject.settings.templatePath;
    const templateFileName = this.getTemplateFileName(templateType);
    const templateFilePath = `${templatePath}/${templateFileName}`;
    try {
      const templateFile = this.app.vault.getAbstractFileByPath(templateFilePath);
      if (!templateFile) {
        console.warn(`Template file not found: ${templateFilePath}`);
        return this.getDefaultTemplate(templateType);
      }
      return await this.app.vault.read(templateFile);
    } catch (error) {
      console.error(`Failed to read template file: ${templateFilePath}`, error);
      return this.getDefaultTemplate(templateType);
    }
  }
  /**
   * 获取模板文件名
   * Get template file name for given type
   */
  getTemplateFileName(templateType) {
    switch (templateType) {
      case "character":
        return "\u89D2\u8272\u6A21\u677F.md";
      case "location":
        return "\u5730\u70B9\u6A21\u677F.md";
      case "scene":
        return "\u573A\u666F\u6A21\u677F.md";
      default:
        throw new Error(`Unknown template type: ${templateType}`);
    }
  }
  /**
   * 获取默认模板内容
   * Get default template content if template file doesn't exist
   */
  getDefaultTemplate(templateType) {
    if (this.settings) {
      switch (templateType) {
        case "character":
          return this.settings.defaultCharacterTemplate;
        case "location":
          return this.settings.defaultLocationTemplate;
        case "scene":
          return this.settings.defaultSceneTemplate;
      }
    }
    switch (templateType) {
      case "character":
        return `---
tags: [character]
faction: ""
status: "alive"
age: 0
goals: ""
relationships: []
appearances: []
---

# {{title}}

## \u57FA\u672C\u4FE1\u606F

- **\u59D3\u540D**: {{title}}
- **\u5E74\u9F84**: 
- **\u6027\u522B**: 
- **\u804C\u4E1A**: 
- **\u6240\u5C5E\u9635\u8425**: 

## \u5916\u8C8C\u63CF\u8FF0



## \u6027\u683C\u7279\u5F81



## \u80CC\u666F\u6545\u4E8B



## \u89D2\u8272\u76EE\u6807



## \u4EBA\u9645\u5173\u7CFB



## \u91CD\u8981\u4E8B\u4EF6

`;
      case "location":
        return `---
tags: [location]
region: ""
significance: ""
connected_locations: []
scenes: []
---

# {{title}}

## \u57FA\u672C\u4FE1\u606F

- **\u5730\u70B9\u540D\u79F0**: {{title}}
- **\u6240\u5C5E\u533A\u57DF**: 
- **\u91CD\u8981\u7A0B\u5EA6**: 

## \u5730\u70B9\u63CF\u8FF0



## \u5730\u7406\u4F4D\u7F6E



## \u5386\u53F2\u80CC\u666F



## \u76F8\u5173\u89D2\u8272



## \u53D1\u751F\u7684\u91CD\u8981\u4E8B\u4EF6

`;
      case "scene":
        return `---
tags: [scene]
status: "outline"
pov: ""
location: ""
story_time: ""
synopsis: ""
word_count: 0
chapter_index: 1
scene_index: 1
---

# {{title}}

## \u573A\u666F\u6897\u6982



## \u573A\u666F\u5185\u5BB9

`;
      default:
        return "";
    }
  }
  /**
   * 处理模板内容，替换占位符
   * Process template content and replace placeholders
   */
  processTemplate(templateContent, file) {
    const fileName = file.basename;
    let processedContent = templateContent.replace(/\{\{title\}\}/g, fileName);
    if (file.path.includes("/10_\u7A3F\u4EF6/")) {
      const { chapterIndex, sceneIndex } = this.parseSceneIndices(file.path, fileName);
      processedContent = processedContent.replace(/chapter_index: 1/g, `chapter_index: ${chapterIndex}`);
      processedContent = processedContent.replace(/scene_index: 1/g, `scene_index: ${sceneIndex}`);
    }
    return processedContent;
  }
  /**
   * 解析场景的章节和场景索引
   * Parse chapter and scene indices from file path and name
   */
  parseSceneIndices(filePath, fileName) {
    const indexMatch = fileName.match(/^(\d+)-(\d+)/);
    if (indexMatch) {
      return {
        chapterIndex: parseInt(indexMatch[1]),
        sceneIndex: parseInt(indexMatch[2])
      };
    }
    const pathParts = filePath.split("/");
    let chapterIndex = 1;
    for (const part of pathParts) {
      const chapterMatch = part.match(/第?(\d+)章/);
      if (chapterMatch) {
        chapterIndex = parseInt(chapterMatch[1]);
        break;
      }
    }
    return { chapterIndex, sceneIndex: 1 };
  }
  /**
   * 检查是否为默认内容
   * Check if content is default/empty content
   */
  isDefaultContent(content) {
    const trimmedContent = content.trim();
    if (!trimmedContent) {
      return true;
    }
    const lines = trimmedContent.split("\n").filter((line) => line.trim());
    if (lines.length === 1 && lines[0].startsWith("#")) {
      return true;
    }
    return false;
  }
  /**
   * 手动应用模板到现有文件
   * Manually apply template to existing file
   */
  async applyTemplateManually(file, templateType) {
    try {
      const currentContent = await this.app.vault.read(file);
      if (currentContent.trim() && !this.isDefaultContent(currentContent)) {
        console.warn(`File ${file.path} already has content. Manual template application requires user confirmation.`);
        return { success: false, templateType, error: "File has existing content, user confirmation required" };
      }
      const templateContent = await this.getTemplateContent(templateType);
      if (!templateContent) {
        return { success: false, templateType, error: `Template not found for type: ${templateType}` };
      }
      const processedContent = this.processTemplate(templateContent, file);
      await this.app.vault.modify(file, processedContent);
      console.log(`Template manually applied: ${templateType} template to ${file.path}`);
      return { success: true, templateType };
    } catch (error) {
      console.error("Failed to manually apply template:", error);
      return {
        success: false,
        templateType,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * 检查模板文件是否存在
   * Check if template files exist
   */
  async checkTemplateFiles() {
    if (!this.projectService.currentProject) {
      return { character: false, location: false, scene: false };
    }
    const templatePath = this.projectService.currentProject.settings.templatePath;
    const results = {
      character: false,
      location: false,
      scene: false
    };
    for (const templateType of ["character", "location", "scene"]) {
      const templateFileName = this.getTemplateFileName(templateType);
      const templateFilePath = `${templatePath}/${templateFileName}`;
      const templateFile = this.app.vault.getAbstractFileByPath(templateFilePath);
      results[templateType] = !!templateFile;
    }
    return results;
  }
  /**
   * 创建默认模板文件
   * Create default template files
   */
  async createDefaultTemplateFiles() {
    if (!this.projectService.currentProject) {
      throw new Error("No project loaded");
    }
    const templatePath = this.projectService.currentProject.settings.templatePath;
    const templateFolder = this.app.vault.getAbstractFileByPath(templatePath);
    if (!templateFolder) {
      await this.app.vault.createFolder(templatePath);
    }
    for (const templateType of ["character", "location", "scene"]) {
      const templateFileName = this.getTemplateFileName(templateType);
      const templateFilePath = `${templatePath}/${templateFileName}`;
      const existingFile = this.app.vault.getAbstractFileByPath(templateFilePath);
      if (existingFile) {
        console.log(`Template file already exists: ${templateFilePath}`);
        continue;
      }
      const defaultContent = this.getDefaultTemplate(templateType);
      await this.app.vault.create(templateFilePath, defaultContent);
      console.log(`Created default template file: ${templateFilePath}`);
    }
  }
};

// src/modals/ProjectCreationModal.ts
var import_obsidian2 = require("obsidian");

// src/services/ActivationService.ts
var ActivationService = class {
  constructor() {
    this.supabaseUrl = "https://kbfwajzlaswbqesgxedu.supabase.co";
    this.supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtiZndhanpsYXN3YnFlc2d4ZWR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDcwMjU5MjYsImV4cCI6MjA2MjYwMTkyNn0.RyoKxCOwAzGnwD2B1mjm2s9IOb1btKcrN94jf2RtPbQ";
  }
  /**
   * 验证激活码
   * Verify activation code
   */
  async verifyActivationCode(code) {
    try {
      console.log(`\u{1F511} Verifying activation code: ${code}`);
      if (!code || code.trim().length === 0) {
        return {
          success: false,
          message: "\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801"
        };
      }
      const response = await this.queryActivationCode(code.trim());
      if (!response.success) {
        return {
          success: false,
          message: response.message || "\u67E5\u8BE2\u6FC0\u6D3B\u7801\u5931\u8D25"
        };
      }
      const codeData = response.data;
      if (codeData.status === "used") {
        return {
          success: false,
          message: "\u6B64\u6FC0\u6D3B\u7801\u5DF2\u88AB\u4F7F\u7528"
        };
      }
      const updateResult = await this.markCodeAsUsed(codeData.id);
      if (!updateResult.success) {
        return {
          success: false,
          message: "\u6FC0\u6D3B\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5"
        };
      }
      console.log(`\u2705 Activation code verified successfully: ${code}`);
      return {
        success: true,
        message: "\u6FC0\u6D3B\u6210\u529F\uFF01\u6B22\u8FCE\u4F7F\u7528\u7EC7\u6587\u8005\u6B63\u5F0F\u7248",
        data: codeData
      };
    } catch (error) {
      console.error("\u274C Activation verification failed:", error);
      return {
        success: false,
        message: "\u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u540E\u91CD\u8BD5"
      };
    }
  }
  /**
   * 查询激活码
   * Query activation code from database
   */
  async queryActivationCode(code) {
    try {
      const response = await fetch(`${this.supabaseUrl}/rest/v1/activation_codes?code=eq.${encodeURIComponent(code)}`, {
        method: "GET",
        headers: {
          "apikey": this.supabaseKey,
          "Authorization": `Bearer ${this.supabaseKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        }
      });
      if (!response.ok) {
        console.error(`\u274C Supabase query failed: ${response.status} ${response.statusText}`);
        return {
          success: false,
          message: "\u67E5\u8BE2\u6FC0\u6D3B\u7801\u5931\u8D25"
        };
      }
      const data = await response.json();
      if (!Array.isArray(data) || data.length === 0) {
        return {
          success: false,
          message: "\u6FC0\u6D3B\u7801\u4E0D\u5B58\u5728\u6216\u65E0\u6548"
        };
      }
      return {
        success: true,
        data: data[0]
      };
    } catch (error) {
      console.error("\u274C Query activation code error:", error);
      return {
        success: false,
        message: "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25"
      };
    }
  }
  /**
   * 标记激活码为已使用
   * Mark activation code as used
   */
  async markCodeAsUsed(codeId) {
    try {
      const response = await fetch(`${this.supabaseUrl}/rest/v1/activation_codes?id=eq.${codeId}`, {
        method: "PATCH",
        headers: {
          "apikey": this.supabaseKey,
          "Authorization": `Bearer ${this.supabaseKey}`,
          "Content-Type": "application/json",
          "Prefer": "return=representation"
        },
        body: JSON.stringify({
          status: "used",
          used_at: new Date().toISOString()
        })
      });
      if (!response.ok) {
        console.error(`\u274C Supabase update failed: ${response.status} ${response.statusText}`);
        return {
          success: false,
          message: "\u66F4\u65B0\u6FC0\u6D3B\u7801\u72B6\u6001\u5931\u8D25"
        };
      }
      return {
        success: true
      };
    } catch (error) {
      console.error("\u274C Mark code as used error:", error);
      return {
        success: false,
        message: "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25"
      };
    }
  }
  /**
   * 检查许可证类型
   * Check license type
   */
  static isFullVersion(licenseType) {
    return licenseType === "full";
  }
  /**
   * 检查是否为试用版
   * Check if trial version
   */
  static isTrialVersion(licenseType) {
    return licenseType === "trial";
  }
  /**
   * 获取许可证显示名称
   * Get license display name
   */
  static getLicenseDisplayName(licenseType) {
    return licenseType === "full" ? "\u6B63\u5F0F\u7248" : "\u8BD5\u7528\u7248";
  }
  /**
   * 保存许可证信息到本地存储
   * Save license information to local storage
   */
  saveLicenseInfo(licenseType, activationCode) {
    try {
      const licenseInfo = {
        licenseType,
        activationCode,
        activatedAt: new Date().toISOString()
      };
      if (typeof localStorage !== "undefined") {
        localStorage.setItem("storyweaver_license", JSON.stringify(licenseInfo));
        console.log("\u2705 License information saved to local storage");
      }
    } catch (error) {
      console.error("\u274C Failed to save license information:", error);
    }
  }
  /**
   * 从本地存储读取许可证信息
   * Read license information from local storage
   */
  loadLicenseInfo() {
    try {
      if (typeof localStorage === "undefined") {
        return null;
      }
      const stored = localStorage.getItem("storyweaver_license");
      if (!stored) {
        return null;
      }
      const licenseInfo = JSON.parse(stored);
      console.log("\u2705 License information loaded from local storage");
      return licenseInfo;
    } catch (error) {
      console.error("\u274C Failed to load license information:", error);
      return null;
    }
  }
  /**
   * 清除本地许可证信息
   * Clear local license information
   */
  clearLicenseInfo() {
    try {
      if (typeof localStorage !== "undefined") {
        localStorage.removeItem("storyweaver_license");
        console.log("\u2705 License information cleared from local storage");
      }
    } catch (error) {
      console.error("\u274C Failed to clear license information:", error);
    }
  }
  /**
   * 检查本地许可证状态
   * Check local license status
   */
  checkLocalLicenseStatus() {
    const licenseInfo = this.loadLicenseInfo();
    return (licenseInfo == null ? void 0 : licenseInfo.licenseType) || "trial";
  }
};

// src/modals/ProjectCreationModal.ts
var ProjectCreationModal = class extends import_obsidian2.Modal {
  constructor(app, projectService, activationService, licenseType = "trial") {
    super(app);
    this.projectName = "";
    this.projectPath = "";
    this.projectService = projectService;
    this.activationService = activationService;
    this.licenseType = licenseType;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u521B\u5EFA\u65B0\u5199\u4F5C\u9879\u76EE" });
    if (!this.checkCanCreateProject()) {
      this.showTrialLimitMessage(contentEl);
      return;
    }
    if (ActivationService.isTrialVersion(this.licenseType)) {
      this.showTrialWarning(contentEl);
    }
    new import_obsidian2.Setting(contentEl).setName("\u9879\u76EE\u540D\u79F0").setDesc("\u4E3A\u60A8\u7684\u5C0F\u8BF4\u9879\u76EE\u8D77\u4E00\u4E2A\u540D\u5B57").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A\u6211\u7684\u7B2C\u4E00\u90E8\u5C0F\u8BF4").setValue(this.projectName).onChange(async (value) => {
      this.projectName = value;
      if (value && !this.projectPath) {
        this.projectPath = this.sanitizeProjectName(value);
        this.updatePathDisplay();
      }
    }));
    new import_obsidian2.Setting(contentEl).setName("\u9879\u76EE\u8DEF\u5F84").setDesc("\u9879\u76EE\u5C06\u5728\u6B64\u8DEF\u5F84\u4E0B\u521B\u5EFA\u6587\u4EF6\u5939\u7ED3\u6784").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1A\u6211\u7684\u5C0F\u8BF4\u9879\u76EE").setValue(this.projectPath).onChange(async (value) => {
      this.projectPath = value;
    }));
    const structureEl = contentEl.createDiv("project-structure-info");
    structureEl.createEl("h3", { text: "\u9879\u76EE\u7ED3\u6784\u9884\u89C8" });
    const structureList = structureEl.createEl("ul");
    const folders = [
      "10_\u7A3F\u4EF6 - \u5B58\u653E\u7AE0\u8282\u548C\u573A\u666F\u6587\u4EF6",
      "20_\u89D2\u8272 - \u89D2\u8272\u8BBE\u5B9A\u548C\u4EBA\u7269\u6863\u6848",
      "30_\u5730\u70B9 - \u5730\u70B9\u8BBE\u5B9A\u548C\u573A\u666F\u63CF\u8FF0",
      "40_\u8BBE\u5B9A - \u4E16\u754C\u89C2\u548C\u80CC\u666F\u8BBE\u5B9A",
      "80_\u6A21\u677F - \u81EA\u5B9A\u4E49\u6A21\u677F\u6587\u4EF6",
      "90_\u56DE\u6536\u7AD9 - \u5DF2\u5220\u9664\u7684\u5185\u5BB9\u5907\u4EFD"
    ];
    folders.forEach((folder) => {
      structureList.createEl("li", { text: folder });
    });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const createButton = buttonContainer.createEl("button", {
      text: "\u521B\u5EFA\u9879\u76EE",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", async () => {
      await this.createProject();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * 清理项目名称，生成合适的路径
   * Sanitize project name for path generation
   */
  sanitizeProjectName(name) {
    return name.replace(/[^\w\s\u4e00-\u9fa5]/g, "").replace(/\s+/g, "-").toLowerCase();
  }
  /**
   * 更新路径显示
   * Update path display
   */
  updatePathDisplay() {
    const pathInput = this.contentEl.querySelector('input[placeholder*="\u9879\u76EE\u8DEF\u5F84"]');
    if (pathInput) {
      pathInput.value = this.projectPath;
    }
  }
  /**
   * 创建项目
   * Create the project
   */
  async createProject() {
    if (!this.projectName.trim()) {
      new import_obsidian2.Notice("\u8BF7\u8F93\u5165\u9879\u76EE\u540D\u79F0");
      return;
    }
    if (!this.projectPath.trim()) {
      new import_obsidian2.Notice("\u8BF7\u8F93\u5165\u9879\u76EE\u8DEF\u5F84");
      return;
    }
    try {
      new import_obsidian2.Notice("\u6B63\u5728\u521B\u5EFA\u9879\u76EE...");
      await this.projectService.createProject(this.projectName.trim(), this.projectPath.trim());
      new import_obsidian2.Notice(`\u9879\u76EE "${this.projectName}" \u521B\u5EFA\u6210\u529F\uFF01`);
      this.close();
      const dashboardPath = `${this.projectPath.trim()}/_project.md`;
      const dashboardFile = this.app.vault.getAbstractFileByPath(dashboardPath);
      if (dashboardFile) {
        await this.app.workspace.openLinkText(dashboardPath, "", false);
      }
    } catch (error) {
      console.error("Failed to create project:", error);
      new import_obsidian2.Notice(`\u521B\u5EFA\u9879\u76EE\u5931\u8D25: ${error.message}`);
    }
  }
  /**
   * 检查是否可以创建项目
   * Check if can create project
   */
  checkCanCreateProject() {
    if (ActivationService.isFullVersion(this.licenseType)) {
      return true;
    }
    const existingProjects = this.getExistingProjectCount();
    return existingProjects < 1;
  }
  /**
   * 获取现有项目数量
   * Get existing project count
   */
  getExistingProjectCount() {
    const files = this.app.vault.getFiles();
    const projectFiles = files.filter((file) => file.name === "_project.md");
    return projectFiles.length;
  }
  /**
   * 获取现有项目数量（保持向后兼容）
   * Get existing projects count (backward compatibility)
   */
  getExistingProjectsCount() {
    return this.getExistingProjectCount();
  }
  /**
   * 显示试用版限制消息
   * Show trial version limit message
   */
  showTrialLimitMessage(contentEl) {
    const warningEl = contentEl.createDiv("trial-limit-warning");
    warningEl.style.cssText = `
      padding: 25px;
      background: linear-gradient(135deg, #fef2f2 0%, #fdf2f8 100%);
      border: 2px solid #fecaca;
      border-radius: 12px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    `;
    const titleContainer = warningEl.createDiv();
    titleContainer.style.cssText = "margin-bottom: 20px;";
    const iconEl = titleContainer.createEl("div", {
      text: "\u{1F6AB}",
      attr: { style: "font-size: 48px; margin-bottom: 10px;" }
    });
    titleContainer.createEl("h3", {
      text: "\u8BD5\u7528\u7248\u9879\u76EE\u6570\u91CF\u9650\u5236",
      attr: { style: "color: #dc2626; margin: 0; font-size: 20px; font-weight: bold;" }
    });
    const descContainer = warningEl.createDiv();
    descContainer.style.cssText = "margin-bottom: 25px;";
    descContainer.createEl("p", {
      text: `\u8BD5\u7528\u7248\u6700\u591A\u53EA\u80FD\u521B\u5EFA 1 \u4E2A\u9879\u76EE\uFF0C\u60A8\u5DF2\u8FBE\u5230\u9650\u5236\u3002`,
      attr: { style: "margin-bottom: 12px; color: #7f1d1d; font-size: 16px;" }
    });
    descContainer.createEl("p", {
      text: `\u5F53\u524D\u9879\u76EE\u6570\u91CF: ${this.getExistingProjectCount()} / 1`,
      attr: { style: "margin-bottom: 15px; color: #991b1b; font-weight: bold;" }
    });
    const benefitsEl = warningEl.createDiv();
    benefitsEl.style.cssText = `
      background: rgba(255, 255, 255, 0.7);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 25px;
      text-align: left;
    `;
    benefitsEl.createEl("h4", {
      text: "\u5347\u7EA7\u5230\u6B63\u5F0F\u7248\uFF0C\u4EAB\u53D7\u5B8C\u6574\u529F\u80FD\uFF1A",
      attr: { style: "color: #059669; margin: 0 0 10px 0; font-size: 16px;" }
    });
    const benefitsList = benefitsEl.createEl("ul");
    benefitsList.style.cssText = "margin: 0; padding-left: 20px; color: #065f46;";
    const benefits = [
      "\u2705 \u521B\u5EFA\u65E0\u9650\u4E2A\u5199\u4F5C\u9879\u76EE",
      "\u2705 \u5B8C\u6574\u7684\u89D2\u8272\u548C\u5730\u70B9\u7BA1\u7406",
      "\u2705 \u9AD8\u7EA7\u65F6\u95F4\u7EBF\u548C\u5927\u7EB2\u529F\u80FD",
      "\u2705 \u4E13\u4E1A\u7684\u5BFC\u51FA\u548C\u5907\u4EFD\u529F\u80FD",
      "\u2705 \u4F18\u5148\u6280\u672F\u652F\u6301"
    ];
    benefits.forEach((benefit) => {
      const li = benefitsList.createEl("li");
      li.textContent = benefit;
      li.style.marginBottom = "5px";
    });
    const buttonContainer = warningEl.createDiv();
    buttonContainer.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    `;
    const upgradeButton = buttonContainer.createEl("button", {
      text: "\u{1F511} \u7ACB\u5373\u6FC0\u6D3B\u6B63\u5F0F\u7248",
      attr: {
        style: `
          background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-size: 15px;
          font-weight: bold;
          box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
          transition: all 0.2s ease;
        `
      }
    });
    upgradeButton.addEventListener("mouseenter", () => {
      upgradeButton.style.transform = "translateY(-1px)";
      upgradeButton.style.boxShadow = "0 4px 8px rgba(220, 38, 38, 0.4)";
    });
    upgradeButton.addEventListener("mouseleave", () => {
      upgradeButton.style.transform = "translateY(0)";
      upgradeButton.style.boxShadow = "0 2px 4px rgba(220, 38, 38, 0.3)";
    });
    upgradeButton.addEventListener("click", () => {
      this.openActivationSettings();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "\u7A0D\u540E\u518D\u8BF4",
      attr: {
        style: `
          background: #6b7280;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-size: 15px;
          transition: all 0.2s ease;
        `
      }
    });
    cancelButton.addEventListener("mouseenter", () => {
      cancelButton.style.background = "#4b5563";
    });
    cancelButton.addEventListener("mouseleave", () => {
      cancelButton.style.background = "#6b7280";
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  /**
   * 打开激活设置页面
   * Open activation settings page
   */
  openActivationSettings() {
    this.close();
    try {
      this.app.setting.open();
      this.app.setting.openTabById("story-weaver-plugin");
    } catch (error) {
      console.error("Failed to open settings:", error);
      new import_obsidian2.Notice("\u65E0\u6CD5\u6253\u5F00\u8BBE\u7F6E\u9875\u9762\uFF0C\u8BF7\u624B\u52A8\u524D\u5F80\u8BBE\u7F6E > \u63D2\u4EF6\u9009\u9879 > Story Weaver");
    }
  }
  /**
   * 显示试用版警告
   * Show trial version warning
   */
  showTrialWarning(contentEl) {
    const warningEl = contentEl.createDiv("trial-warning");
    warningEl.style.cssText = `
      padding: 16px;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 1px solid #fbbf24;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    `;
    const messageContainer = warningEl.createDiv();
    messageContainer.style.cssText = "flex: 1;";
    const currentCount = this.getExistingProjectCount();
    const maxCount = 1;
    messageContainer.createEl("p", {
      text: `\u26A0\uFE0F \u8BD5\u7528\u7248\u63D0\u9192\uFF1A\u60A8\u6B63\u5728\u4F7F\u7528\u8BD5\u7528\u7248 (${currentCount}/${maxCount} \u4E2A\u9879\u76EE)`,
      attr: { style: "margin: 0 0 5px 0; color: #92400e; font-size: 14px; font-weight: bold;" }
    });
    messageContainer.createEl("p", {
      text: "\u5347\u7EA7\u5230\u6B63\u5F0F\u7248\u53EF\u521B\u5EFA\u65E0\u9650\u4E2A\u9879\u76EE\u5E76\u4EAB\u53D7\u5B8C\u6574\u529F\u80FD\u3002",
      attr: { style: "margin: 0; color: #78350f; font-size: 13px;" }
    });
    const upgradeBtn = warningEl.createEl("button", {
      text: "\u5347\u7EA7",
      attr: {
        style: `
          background: #f59e0b;
          color: white;
          border: none;
          padding: 6px 12px;
          border-radius: 4px;
          cursor: pointer;
          font-size: 12px;
          margin-left: 15px;
          transition: background 0.2s ease;
        `
      }
    });
    upgradeBtn.addEventListener("mouseenter", () => {
      upgradeBtn.style.background = "#d97706";
    });
    upgradeBtn.addEventListener("mouseleave", () => {
      upgradeBtn.style.background = "#f59e0b";
    });
    upgradeBtn.addEventListener("click", (e) => {
      e.preventDefault();
      this.openActivationSettings();
    });
  }
};

// src/services/DashboardRenderer.ts
var import_obsidian3 = require("obsidian");
var DashboardRenderer = class extends import_obsidian3.Component {
  constructor(app, projectService) {
    super();
    this.app = app;
    this.projectService = projectService;
  }
  /**
   * 创建元素的辅助方法
   * Helper method to create elements
   */
  createElement(tag, className, parent) {
    const element = document.createElement(tag);
    if (className) {
      element.className = className;
    }
    if (parent) {
      parent.appendChild(element);
    }
    return element;
  }
  /**
   * 处理项目仪表盘标记
   * Process project dashboard markers in markdown
   */
  async processMarkdown(element, context) {
    console.log(`DashboardRenderer processing: ${context.sourcePath}`);
    if (!this.isProjectDashboard(context.sourcePath)) {
      console.log(`Not a project dashboard: ${context.sourcePath}`);
      return;
    }
    console.log(`Processing project dashboard: ${context.sourcePath}`);
    const projectLoaded = await this.projectService.autoLoadProject(context.sourcePath);
    if (!projectLoaded) {
      console.log(`Project not loaded for: ${context.sourcePath}`);
      this.renderProjectNotLoaded(element);
      return;
    }
    console.log(`Project loaded, processing dashboard elements`);
    this.processDashboardElements(element);
  }
  /**
   * 检查是否是项目仪表盘文件
   * Check if the file is a project dashboard
   */
  isProjectDashboard(sourcePath) {
    return sourcePath.endsWith("/_project.md");
  }
  /**
   * 处理仪表盘元素
   * Process dashboard elements
   */
  processDashboardElements(element) {
    this.replacePlaceholders(element);
    this.renderStatusSwitcher(element);
    this.replaceDataviewExpressions(element);
    const statsSection = this.findStatsSection(element);
    if (statsSection) {
      this.renderProjectStats(statsSection);
    }
    this.addProjectOverviewCard(element);
  }
  /**
   * 替换占位符
   * Replace placeholders with actual data
   */
  replacePlaceholders(element) {
    try {
      const stats = this.projectService.getProjectStats();
      const project = this.projectService.currentProject;
      if (!project) {
        console.log("No project loaded, skipping placeholder replacement");
        return;
      }
      console.log("Replacing placeholders with stats:", stats);
      const dailyTarget = Math.round(project.targetWordCount / 365);
      const todayWords = stats.todayWords;
      const remainingWords = Math.max(0, project.targetWordCount - stats.totalWords);
      const statusInfo = this.projectService.getProjectStatusInfo(project.status);
      const statusDisplay = `${statusInfo.icon} ${statusInfo.label} (${statusInfo.progress}%)`;
      const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null
      );
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent && node.textContent.includes("{{")) {
          textNodes.push(node);
        }
      }
      textNodes.forEach((textNode) => {
        let content = textNode.textContent || "";
        content = content.replace(/\{\{DAILY_TARGET\}\}/g, dailyTarget.toString());
        content = content.replace(/\{\{TODAY_WORDS\}\}/g, todayWords.toString());
        content = content.replace(/\{\{REMAINING_WORDS\}\}/g, remainingWords.toString());
        content = content.replace(/\{\{PROJECT_STATUS\}\}/g, statusDisplay);
        if (content.includes("{{PROJECT_STATUS_SWITCHER}}")) {
          content = content.replace(/\{\{PROJECT_STATUS_SWITCHER\}\}/g, "");
        }
        textNode.textContent = content;
      });
    } catch (error) {
      console.error("Failed to replace placeholders:", error);
    }
  }
  /**
   * 渲染状态切换器
   * Render status switcher
   */
  renderStatusSwitcher(element) {
    var _a, _b;
    try {
      const project = this.projectService.currentProject;
      if (!project)
        return;
      const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null
      );
      let statusSection = null;
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent && node.textContent.includes("\u9879\u76EE\u72B6\u6001")) {
          let parent = node.parentElement;
          while (parent && parent !== element) {
            if (parent.tagName === "H3" || parent.tagName === "DIV" || parent.tagName === "SECTION") {
              statusSection = parent.parentElement || parent;
              break;
            }
            parent = parent.parentElement;
          }
          if (!statusSection) {
            statusSection = node.parentElement;
          }
          break;
        }
      }
      if (!statusSection) {
        console.warn("\u26A0\uFE0F Status section not found, trying alternative approach...");
        const headings = element.querySelectorAll("h3");
        for (const heading of headings) {
          if (((_a = heading.textContent) == null ? void 0 : _a.includes("\u9879\u76EE\u72B6\u6001")) || ((_b = heading.textContent) == null ? void 0 : _b.includes("\u5199\u4F5C\u8FDB\u5EA6"))) {
            statusSection = heading.parentElement || heading;
            console.log("\u2705 Found status section via heading search");
            break;
          }
        }
      }
      if (!statusSection) {
        console.error("\u274C Could not find status section");
        return;
      }
      console.log("\u2705 Status section found, rendering switcher...");
      const existingSwitcher = statusSection.querySelector(".status-switcher");
      if (existingSwitcher) {
        console.log("\u{1F504} Removing existing status switcher...");
        existingSwitcher.remove();
      }
      const switcherContainer = this.createElement("div", "status-switcher", statusSection);
      switcherContainer.style.cssText = `
        margin: 15px 0;
        padding: 15px;
        background: var(--background-secondary);
        border-radius: 8px;
        border: 1px solid var(--background-modifier-border);
      `;
      const statuses = [
        { key: "planning", label: "\u6784\u601D\u4E2D", icon: "\u{1F4DD}", progress: 0 },
        { key: "drafting", label: "\u521D\u7A3F\u4E2D", icon: "\u270F\uFE0F", progress: 25 },
        { key: "revising", label: "\u4FEE\u6539\u4E2D", icon: "\u{1F4D6}", progress: 50 },
        { key: "editing", label: "\u6821\u5BF9\u4E2D", icon: "\u{1F50D}", progress: 75 },
        { key: "completed", label: "\u5DF2\u5B8C\u6210", icon: "\u2705", progress: 100 }
      ];
      const statusGrid = this.createElement("div", "status-grid", switcherContainer);
      statusGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 10px;
      `;
      statuses.forEach((status) => {
        const statusButton = this.createElement("button", "status-button", statusGrid);
        const isActive = project.status === status.key;
        statusButton.style.cssText = `
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 12px 8px;
          border: 2px solid ${isActive ? "var(--color-accent)" : "var(--background-modifier-border)"};
          background: ${isActive ? "var(--color-accent-2)" : "var(--background-primary)"};
          border-radius: 6px;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 12px;
        `;
        const iconEl = this.createElement("div", "status-icon", statusButton);
        iconEl.textContent = status.icon;
        iconEl.style.cssText = "font-size: 20px; margin-bottom: 4px;";
        const labelEl = this.createElement("div", "status-label", statusButton);
        labelEl.textContent = status.label;
        labelEl.style.cssText = "font-weight: 500; margin-bottom: 2px;";
        const progressEl = this.createElement("div", "status-progress", statusButton);
        progressEl.textContent = `${status.progress}%`;
        progressEl.style.cssText = "font-size: 10px; color: var(--text-muted);";
        statusButton.addEventListener("click", async () => {
          console.log(`\u{1F504} Status button clicked: ${status.key}`);
          try {
            console.log(`\u{1F4DD} Updating project status to: ${status.key}`);
            await this.projectService.updateProjectStatus(status.key);
            console.log(`\u2705 Project status updated successfully to: ${status.key}`);
            this.updateStatusDisplayImmediate(status.key, statusGrid);
            setTimeout(() => {
              console.log("\u{1F504} Refreshing dashboard...");
              this.refreshActiveDashboard();
            }, 100);
          } catch (error) {
            console.error("\u274C Failed to update project status:", error);
          }
        });
        statusButton.addEventListener("mouseenter", () => {
          if (!isActive) {
            statusButton.style.borderColor = "var(--color-accent)";
            statusButton.style.background = "var(--background-modifier-hover)";
          }
        });
        statusButton.addEventListener("mouseleave", () => {
          if (!isActive) {
            statusButton.style.borderColor = "var(--background-modifier-border)";
            statusButton.style.background = "var(--background-primary)";
          }
        });
      });
    } catch (error) {
      console.error("Failed to render status switcher:", error);
    }
  }
  /**
   * 立即更新状态显示
   * Update status display immediately
   */
  updateStatusDisplayImmediate(newStatus, statusGrid) {
    try {
      console.log(`\u{1F504} Updating status display immediately to: ${newStatus}`);
      const statusButtons = statusGrid.querySelectorAll(".status-button");
      statusButtons.forEach((button, index) => {
        const statusKey = ["planning", "drafting", "revising", "editing", "completed"][index];
        const isActive = statusKey === newStatus;
        const buttonEl = button;
        buttonEl.style.border = `2px solid ${isActive ? "var(--color-accent)" : "var(--background-modifier-border)"}`;
        buttonEl.style.background = isActive ? "var(--color-accent-2)" : "var(--background-primary)";
      });
      const project = this.projectService.currentProject;
      if (project) {
        const statusInfo = this.projectService.getProjectStatusInfo(newStatus);
        const statusDisplay = `${statusInfo.icon} ${statusInfo.label} (${statusInfo.progress}%)`;
        const walker = document.createTreeWalker(
          document.body,
          NodeFilter.SHOW_TEXT,
          null
        );
        let node;
        while (node = walker.nextNode()) {
          if (node.textContent && node.textContent.includes("\u5F53\u524D\u72B6\u6001")) {
            const parent = node.parentElement;
            if (parent) {
              const statusSpan = parent.querySelector("span") || parent;
              if (statusSpan.textContent && (statusSpan.textContent.includes("\u6784\u601D\u4E2D") || statusSpan.textContent.includes("\u521D\u7A3F\u4E2D") || statusSpan.textContent.includes("\u4FEE\u6539\u4E2D") || statusSpan.textContent.includes("\u6821\u5BF9\u4E2D") || statusSpan.textContent.includes("\u5DF2\u5B8C\u6210"))) {
                statusSpan.textContent = statusDisplay;
                console.log(`\u2705 Updated status text to: ${statusDisplay}`);
                break;
              }
            }
          }
        }
      }
      console.log(`\u2705 Status display updated immediately`);
    } catch (error) {
      console.error("Failed to update status display immediately:", error);
    }
  }
  /**
   * 替换 Dataview 表达式
   * Replace Dataview expressions with actual data
   */
  replaceDataviewExpressions(element) {
    try {
      const stats = this.projectService.getProjectStats();
      const project = this.projectService.currentProject;
      if (!project) {
        console.log("No project loaded, skipping Dataview replacement");
        return;
      }
      console.log("Replacing Dataview expressions with stats:", stats);
      const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null
      );
      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent && (node.textContent.includes("(disabled; enable in settings)") || node.textContent.includes("dv.pages") || node.textContent.includes("$="))) {
          textNodes.push(node);
        }
      }
      textNodes.forEach((textNode) => {
        let content = textNode.textContent || "";
        if (content.includes("\u65E5\u5747\u76EE\u6807") && content.includes("(disabled; enable in settings)")) {
          const dailyTarget = Math.round(project.targetWordCount / 365);
          content = content.replace(/\(disabled; enable in settings\)/, `${dailyTarget}`);
        } else if (content.includes("\u4ECA\u65E5\u603B\u5B57\u6570") && content.includes("(disabled; enable in settings)")) {
          content = content.replace(/\(disabled; enable in settings\)/, `${stats.todayWords}`);
        } else if (content.includes("\u5269\u4F59\u5B57\u6570") && content.includes("(disabled; enable in settings)")) {
          const remainingWords = Math.max(0, project.targetWordCount - stats.totalWords);
          content = content.replace(/\(disabled; enable in settings\)/, `${remainingWords}`);
        } else if (content.includes("10_\u7A3F\u4EF6")) {
          if (content.includes("(disabled; enable in settings)")) {
            content = content.replace(/.*\(disabled; enable in settings\).*/, `${stats.sceneCount} \u4E2A\u6587\u4EF6`);
          } else if (content.includes("dv.pages") || content.includes("$=")) {
            content = content.replace(/`\$=.*?`/, `\`${stats.sceneCount}\``);
          }
        } else if (content.includes("20_\u89D2\u8272")) {
          if (content.includes("(disabled; enable in settings)")) {
            content = content.replace(/.*\(disabled; enable in settings\).*/, `${stats.characterCount} \u4E2A\u89D2\u8272`);
          } else if (content.includes("dv.pages") || content.includes("$=")) {
            content = content.replace(/`\$=.*?`/, `\`${stats.characterCount}\``);
          }
        } else if (content.includes("30_\u5730\u70B9")) {
          if (content.includes("(disabled; enable in settings)")) {
            content = content.replace(/.*\(disabled; enable in settings\).*/, `${stats.locationCount} \u4E2A\u5730\u70B9`);
          } else if (content.includes("dv.pages") || content.includes("$=")) {
            content = content.replace(/`\$=.*?`/, `\`${stats.locationCount}\``);
          }
        } else if (content.includes("40_\u8BBE\u5B9A")) {
          if (content.includes("(disabled; enable in settings)")) {
            content = content.replace(/.*\(disabled; enable in settings\).*/, `1 \u4E2A\u6587\u4EF6`);
          } else if (content.includes("dv.pages") || content.includes("$=")) {
            content = content.replace(/`\$=.*?`/, `\`1\``);
          }
        }
        textNode.textContent = content;
      });
      const codeElements = element.querySelectorAll("code");
      codeElements.forEach((codeEl) => {
        let content = codeEl.textContent || "";
        if (content.includes("today_words")) {
          codeEl.textContent = stats.todayWords.toString();
        } else if (content.includes("remaining_words")) {
          const remainingWords = Math.max(0, project.targetWordCount - stats.totalWords);
          codeEl.textContent = remainingWords.toString();
        } else if (content.includes("Math.round") && content.includes("365")) {
          const dailyTarget = Math.round(project.targetWordCount / 365);
          codeEl.textContent = dailyTarget.toString();
        } else if (content.includes("dv.pages") || content.includes("$=")) {
          if (content.includes("10_\u7A3F\u4EF6") && content.includes(".length")) {
            codeEl.textContent = stats.sceneCount.toString();
          } else if (content.includes("20_\u89D2\u8272") && content.includes(".length")) {
            codeEl.textContent = stats.characterCount.toString();
          } else if (content.includes("30_\u5730\u70B9") && content.includes(".length")) {
            codeEl.textContent = stats.locationCount.toString();
          } else if (content.includes("40_\u8BBE\u5B9A") && content.includes(".length")) {
            codeEl.textContent = "1";
          } else if (content.includes("word_count") && content.includes("reduce")) {
            codeEl.textContent = stats.totalWords.toString();
          } else if (content.includes("target_word_count")) {
            codeEl.textContent = project.targetWordCount.toString();
          } else if (content.includes("Math.round") && content.includes("100")) {
            codeEl.textContent = `${Math.round(stats.progress * 100)}`;
          }
        }
      });
    } catch (error) {
      console.error("Failed to replace Dataview expressions:", error);
    }
  }
  /**
   * 查找写作统计部分
   * Find writing statistics section
   */
  findStatsSection(element) {
    var _a;
    const headings = element.querySelectorAll("h2");
    for (const heading of headings) {
      if ((_a = heading.textContent) == null ? void 0 : _a.includes("\u5199\u4F5C\u7EDF\u8BA1")) {
        return heading.parentElement || heading;
      }
    }
    return null;
  }
  // findQuickLinksSection 方法已移除
  /**
   * 渲染项目统计信息
   * Render project statistics
   */
  renderProjectStats(container) {
    try {
      const stats = this.projectService.getProjectStats();
      const existingStats = container.querySelector(".project-stats");
      if (existingStats) {
        existingStats.remove();
      }
      const statsContainer = this.createElement("div", "project-stats", container);
      statsContainer.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 20px 0;
        padding: 20px;
        background: var(--background-secondary);
        border-radius: 8px;
        border: 1px solid var(--background-modifier-border);
      `;
      this.createStatCard(statsContainer, "\u603B\u5B57\u6570", stats.totalWords.toLocaleString(), "\u{1F4DD}");
      this.createStatCard(statsContainer, "\u4ECA\u65E5\u65B0\u589E", stats.todayWords.toLocaleString(), "\u270D\uFE0F");
      this.createStatCard(statsContainer, "\u9879\u76EE\u8FDB\u5EA6", `${Math.round(stats.progress * 100)}%`, "\u{1F4CA}");
      this.createStatCard(statsContainer, "\u7AE0\u8282\u6570", stats.chapterCount.toString(), "\u{1F4DA}");
      this.createStatCard(statsContainer, "\u573A\u666F\u6570", stats.sceneCount.toString(), "\u{1F3AC}");
      this.createStatCard(statsContainer, "\u89D2\u8272\u6570", stats.characterCount.toString(), "\u{1F465}");
      this.createProgressBar(statsContainer, stats.progress);
    } catch (error) {
      console.error("Failed to render project stats:", error);
      this.renderStatsError(container);
    }
  }
  /**
   * 创建统计卡片
   * Create statistics card
   */
  createStatCard(container, label, value, icon) {
    const card = this.createElement("div", "stat-card", container);
    card.style.cssText = `
      text-align: center;
      padding: 15px;
      background: var(--background-primary);
      border-radius: 6px;
      border: 1px solid var(--background-modifier-border);
    `;
    const iconEl = this.createElement("div", "stat-icon", card);
    iconEl.textContent = icon;
    iconEl.style.cssText = `
      font-size: 24px;
      margin-bottom: 8px;
    `;
    const valueEl = this.createElement("div", "stat-value", card);
    valueEl.textContent = value;
    valueEl.style.cssText = `
      font-size: 20px;
      font-weight: bold;
      color: var(--text-accent);
      margin-bottom: 4px;
    `;
    const labelEl = this.createElement("div", "stat-label", card);
    labelEl.textContent = label;
    labelEl.style.cssText = `
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
  }
  /**
   * 创建进度条
   * Create progress bar
   */
  createProgressBar(container, progress) {
    const progressContainer = this.createElement("div", "progress-container", container);
    progressContainer.style.cssText = `
      grid-column: 1 / -1;
      margin-top: 10px;
    `;
    const progressLabel = this.createElement("div", "progress-label", progressContainer);
    progressLabel.textContent = "\u9879\u76EE\u8FDB\u5EA6";
    progressLabel.style.cssText = `
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-normal);
    `;
    const progressBar = this.createElement("div", "progress-bar", progressContainer);
    progressBar.style.cssText = `
      width: 100%;
      height: 8px;
      background: var(--background-modifier-border);
      border-radius: 4px;
      overflow: hidden;
    `;
    const progressFill = this.createElement("div", "progress-fill", progressBar);
    progressFill.style.cssText = `
      width: ${Math.min(progress * 100, 100)}%;
      height: 100%;
      background: linear-gradient(90deg, var(--color-accent), var(--color-accent-2));
      transition: width 0.3s ease;
    `;
  }
  /**
   * 渲染统计错误信息
   * Render statistics error message
   */
  renderStatsError(container) {
    const errorContainer = this.createElement("div", "stats-error", container);
    errorContainer.style.cssText = `
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      background: var(--background-secondary);
      border-radius: 8px;
      margin: 20px 0;
    `;
    const errorTitle = this.createElement("p", "", errorContainer);
    errorTitle.textContent = "\u{1F4CA} \u7EDF\u8BA1\u4FE1\u606F\u6682\u65F6\u65E0\u6CD5\u52A0\u8F7D";
    errorTitle.style.cssText = "margin: 0 0 10px 0; font-size: 16px;";
    const errorDesc = this.createElement("p", "", errorContainer);
    errorDesc.textContent = "\u8BF7\u786E\u4FDD\u9879\u76EE\u5DF2\u6B63\u786E\u52A0\u8F7D";
    errorDesc.style.cssText = "margin: 0; font-size: 14px; color: var(--text-muted);";
  }
  // enhanceQuickLinks 方法已移除
  // addFolderStats 方法已移除
  /**
   * 添加项目概览卡片
   * Add project overview card
   */
  addProjectOverviewCard(element) {
    const project = this.projectService.currentProject;
    if (!project)
      return;
    const overviewSection = this.findOverviewSection(element);
    if (!overviewSection)
      return;
    const card = this.createElement("div", "project-overview-card", overviewSection);
    card.style.cssText = `
      background: var(--background-secondary);
      border: 1px solid var(--background-modifier-border);
      border-radius: 8px;
      padding: 20px;
      margin: 15px 0;
    `;
    const infoGrid = this.createElement("div", "project-info-grid", card);
    infoGrid.style.cssText = `
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    `;
    this.createInfoItem(infoGrid, "\u521B\u5EFA\u65F6\u95F4", this.formatDate(project.createdDate));
    this.createInfoItem(infoGrid, "\u6700\u540E\u4FEE\u6539", this.formatDate(project.lastModified));
    this.createInfoItem(infoGrid, "\u76EE\u6807\u5B57\u6570", project.targetWordCount.toLocaleString());
    if (project.synopsis) {
      const synopsisEl = this.createElement("div", "project-synopsis", card);
      synopsisEl.style.cssText = `
        padding: 15px;
        background: var(--background-primary);
        border-radius: 6px;
        border-left: 4px solid var(--color-accent);
      `;
      const synopsisLabel = this.createElement("h4", "", synopsisEl);
      synopsisLabel.textContent = "\u9879\u76EE\u7B80\u4ECB";
      synopsisLabel.style.cssText = `
        margin: 0 0 10px 0;
        color: var(--text-accent);
        font-size: 14px;
      `;
      const synopsisText = this.createElement("p", "", synopsisEl);
      synopsisText.textContent = project.synopsis;
      synopsisText.style.cssText = `
        margin: 0;
        line-height: 1.5;
        color: var(--text-normal);
      `;
    }
  }
  /**
   * 查找项目概览部分
   * Find project overview section
   */
  findOverviewSection(element) {
    var _a;
    const headings = element.querySelectorAll("h2");
    for (const heading of headings) {
      if ((_a = heading.textContent) == null ? void 0 : _a.includes("\u9879\u76EE\u6982\u89C8")) {
        return heading.parentElement || heading;
      }
    }
    return null;
  }
  /**
   * 创建信息项
   * Create information item
   */
  createInfoItem(container, label, value) {
    const item = this.createElement("div", "info-item", container);
    item.style.cssText = `
      text-align: center;
      padding: 10px;
      background: var(--background-primary);
      border-radius: 6px;
    `;
    const labelEl = this.createElement("div", "info-label", item);
    labelEl.textContent = label;
    labelEl.style.cssText = `
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
    const valueEl = this.createElement("div", "info-value", item);
    valueEl.textContent = value;
    valueEl.style.cssText = `
      font-size: 16px;
      font-weight: 500;
      color: var(--text-normal);
    `;
  }
  /**
   * 格式化日期
   * Format date for display
   */
  formatDate(date) {
    return date.toLocaleDateString("zh-CN", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
  }
  /**
   * 渲染项目未加载消息
   * Render project not loaded message
   */
  renderProjectNotLoaded(element) {
    const messageContainer = this.createElement("div", "project-not-loaded", element);
    messageContainer.style.cssText = `
      padding: 30px;
      text-align: center;
      background: var(--background-secondary);
      border: 2px dashed var(--background-modifier-border);
      border-radius: 8px;
      margin: 20px 0;
    `;
    const iconEl = this.createElement("div", "not-loaded-icon", messageContainer);
    iconEl.textContent = "\u{1F4C1}";
    iconEl.style.cssText = `
      font-size: 48px;
      margin-bottom: 15px;
    `;
    const titleEl = this.createElement("h3", "", messageContainer);
    titleEl.textContent = "\u9879\u76EE\u672A\u52A0\u8F7D";
    titleEl.style.cssText = `
      margin: 0 0 10px 0;
      color: var(--text-normal);
    `;
    const descEl = this.createElement("p", "", messageContainer);
    descEl.textContent = "\u65E0\u6CD5\u68C0\u6D4B\u5230\u6709\u6548\u7684\u7EC7\u6587\u8005\u9879\u76EE\u3002\u8BF7\u786E\u4FDD\u6B64\u6587\u4EF6\u4F4D\u4E8E\u6B63\u786E\u7684\u9879\u76EE\u7ED3\u6784\u4E2D\u3002";
    descEl.style.cssText = `
      margin: 0;
      color: var(--text-muted);
      line-height: 1.5;
    `;
  }
  /**
   * 渲染统计图表
   * Render statistics charts
   */
  renderStatisticsCharts(container) {
    try {
      const existingCharts = container.querySelector(".statistics-charts");
      if (existingCharts) {
        existingCharts.remove();
      }
      const chartsContainer = this.createElement("div", "statistics-charts", container);
      chartsContainer.style.cssText = `
        margin: 30px 0;
        padding: 20px;
        background: var(--background-secondary);
        border-radius: 8px;
        border: 1px solid var(--background-modifier-border);
      `;
      const chartsTitle = this.createElement("h3", "charts-title", chartsContainer);
      chartsTitle.textContent = "\u{1F4CA} \u7EDF\u8BA1\u56FE\u8868";
      chartsTitle.style.cssText = `
        margin: 0 0 20px 0;
        color: var(--text-normal);
        font-size: 18px;
        font-weight: 600;
      `;
      const chartsGrid = this.createElement("div", "charts-grid", chartsContainer);
      chartsGrid.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      `;
      const pieChartContainer = this.createElement("div", "chart-container", chartsGrid);
      pieChartContainer.style.cssText = `
        background: var(--background-primary);
        border-radius: 6px;
        padding: 15px;
        height: 300px;
        position: relative;
      `;
      const pieCanvas = this.createElement("canvas", "word-distribution-chart", pieChartContainer);
      pieCanvas.style.cssText = "width: 100%; height: 100%;";
      const barChartContainer = this.createElement("div", "chart-container", chartsGrid);
      barChartContainer.style.cssText = `
        background: var(--background-primary);
        border-radius: 6px;
        padding: 15px;
        height: 300px;
        position: relative;
      `;
      const barCanvas = this.createElement("canvas", "progress-chart", barChartContainer);
      barCanvas.style.cssText = "width: 100%; height: 100%;";
      const trendChartContainer = this.createElement("div", "chart-container", chartsContainer);
      trendChartContainer.style.cssText = `
        background: var(--background-primary);
        border-radius: 6px;
        padding: 15px;
        height: 250px;
        position: relative;
        margin-top: 20px;
      `;
      const trendCanvas = this.createElement("canvas", "trend-chart", trendChartContainer);
      trendCanvas.style.cssText = "width: 100%; height: 100%;";
      this.renderActualCharts(pieCanvas, barCanvas, trendCanvas);
    } catch (error) {
      console.error("Failed to render statistics charts:", error);
      this.renderChartsError(container);
    }
  }
  /**
   * 渲染图表错误信息
   * Render charts error message
   */
  renderChartsError(container) {
    const errorContainer = this.createElement("div", "charts-error", container);
    errorContainer.style.cssText = `
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      background: var(--background-secondary);
      border-radius: 8px;
      margin: 20px 0;
    `;
    const errorTitle = this.createElement("p", "", errorContainer);
    errorTitle.textContent = "\u{1F4CA} \u56FE\u8868\u6682\u65F6\u65E0\u6CD5\u52A0\u8F7D";
    errorTitle.style.cssText = "margin: 0 0 10px 0; font-size: 16px;";
    const errorDesc = this.createElement("p", "", errorContainer);
    errorDesc.textContent = "\u8BF7\u786E\u4FDD\u9879\u76EE\u6570\u636E\u5DF2\u6B63\u786E\u52A0\u8F7D";
    errorDesc.style.cssText = "margin: 0; font-size: 14px; color: var(--text-muted);";
  }
  /**
   * 刷新仪表盘内容
   * Refresh dashboard content
   */
  refresh() {
    this.refreshActiveDashboard();
    this.app.workspace.trigger("layout-change");
  }
  /**
   * 刷新当前活动的仪表盘文件
   * Refresh currently active dashboard file
   */
  refreshActiveDashboard() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && this.isProjectDashboard(activeFile.path)) {
      setTimeout(() => {
        this.app.workspace.trigger("layout-change");
        const activeLeaf = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeLeaf) {
          activeLeaf.previewMode.rerender(true);
        }
      }, 100);
    }
  }
  /**
   * 触发所有仪表盘文件的更新
   * Trigger update for all dashboard files
   */
  refreshAllDashboards() {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view.file && this.isProjectDashboard(view.file.path)) {
        setTimeout(() => {
          view.previewMode.rerender(true);
        }, 50);
      }
    });
  }
  /**
   * 渲染实际的图表内容
   * Render actual chart content using HTML/CSS
   */
  renderActualCharts(pieCanvas, barCanvas, trendCanvas) {
    try {
      const stats = this.projectService.getProjectStats();
      this.renderWordDistributionChart(pieCanvas, stats);
      this.renderProgressBarChart(barCanvas, stats);
      this.renderTrendChart(trendCanvas, stats);
    } catch (error) {
      console.error("Failed to render charts:", error);
      this.renderChartsPlaceholder(pieCanvas.parentElement);
    }
  }
  /**
   * 渲染字数分布饼图
   * Render word distribution pie chart
   */
  renderWordDistributionChart(canvas, stats) {
    const container = canvas.parentElement;
    container.removeChild(canvas);
    const title = this.createElement("h4", "chart-title", container);
    title.textContent = "\u{1F4CA} \u5185\u5BB9\u5206\u5E03";
    title.style.cssText = "margin: 0 0 15px 0; text-align: center; color: var(--text-accent);";
    const data = [
      { label: "\u5DF2\u5B8C\u6210\u573A\u666F", value: stats.sceneCount, color: "#4CAF50" },
      { label: "\u89D2\u8272\u8BBE\u5B9A", value: stats.characterCount, color: "#2196F3" },
      { label: "\u5730\u70B9\u8BBE\u5B9A", value: stats.locationCount, color: "#FF9800" },
      { label: "\u7AE0\u8282\u89C4\u5212", value: stats.chapterCount, color: "#9C27B0" }
    ];
    const total = data.reduce((sum, item) => sum + item.value, 0);
    const pieContainer = this.createElement("div", "pie-chart", container);
    pieContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    `;
    const circle = this.createElement("div", "pie-circle", pieContainer);
    circle.style.cssText = `
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: conic-gradient(
        ${data.map((item, index) => {
      const percentage = item.value / total * 100;
      const prevPercentage = data.slice(0, index).reduce((sum, prev) => sum + prev.value / total * 100, 0);
      return `${item.color} ${prevPercentage}% ${prevPercentage + percentage}%`;
    }).join(", ")}
      );
      position: relative;
    `;
    const centerText = this.createElement("div", "pie-center", circle);
    centerText.textContent = total.toString();
    centerText.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      font-weight: bold;
      color: var(--text-normal);
    `;
    const legend = this.createElement("div", "pie-legend", pieContainer);
    legend.style.cssText = `
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    `;
    data.forEach((item) => {
      const legendItem = this.createElement("div", "legend-item", legend);
      legendItem.style.cssText = `
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 12px;
      `;
      const colorBox = this.createElement("div", "legend-color", legendItem);
      colorBox.style.cssText = `
        width: 12px;
        height: 12px;
        background: ${item.color};
        border-radius: 2px;
      `;
      const label = this.createElement("span", "legend-label", legendItem);
      label.textContent = `${item.label} (${item.value})`;
    });
  }
  /**
   * 渲染写作进度柱状图
   * Render progress bar chart
   */
  renderProgressBarChart(canvas, stats) {
    const container = canvas.parentElement;
    container.removeChild(canvas);
    const title = this.createElement("h4", "chart-title", container);
    title.textContent = "\u{1F4C8} \u5199\u4F5C\u8FDB\u5EA6";
    title.style.cssText = "margin: 0 0 15px 0; text-align: center; color: var(--text-accent);";
    const progressContainer = this.createElement("div", "progress-bars", container);
    progressContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 15px;
      padding: 10px;
    `;
    this.createProgressItem(progressContainer, "\u603B\u4F53\u8FDB\u5EA6", stats.progress * 100, "#4CAF50");
    const wordProgress = Math.min(stats.totalWords / 1e5 * 100, 100);
    this.createProgressItem(progressContainer, "\u5B57\u6570\u76EE\u6807", wordProgress, "#2196F3");
    const sceneProgress = stats.sceneCount > 0 ? stats.sceneCount / 50 * 100 : 0;
    this.createProgressItem(progressContainer, "\u573A\u666F\u89C4\u5212", Math.min(sceneProgress, 100), "#FF9800");
    const statsDisplay = this.createElement("div", "stats-display", container);
    statsDisplay.style.cssText = `
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
      font-size: 12px;
      color: var(--text-muted);
    `;
    const totalWords = this.createElement("div", "", statsDisplay);
    totalWords.textContent = `\u603B\u5B57\u6570: ${stats.totalWords.toLocaleString()}`;
    const todayWords = this.createElement("div", "", statsDisplay);
    todayWords.textContent = `\u4ECA\u65E5: ${stats.todayWords.toLocaleString()}`;
  }
  /**
   * 创建进度条项目
   * Create progress bar item
   */
  createProgressItem(container, label, percentage, color) {
    const item = this.createElement("div", "progress-item", container);
    item.style.cssText = "display: flex; flex-direction: column; gap: 5px;";
    const labelEl = this.createElement("div", "progress-label", item);
    labelEl.textContent = `${label} (${Math.round(percentage)}%)`;
    labelEl.style.cssText = "font-size: 12px; color: var(--text-normal);";
    const barBg = this.createElement("div", "progress-bg", item);
    barBg.style.cssText = `
      width: 100%;
      height: 8px;
      background: var(--background-modifier-border);
      border-radius: 4px;
      overflow: hidden;
    `;
    const barFill = this.createElement("div", "progress-fill", barBg);
    barFill.style.cssText = `
      width: ${Math.min(percentage, 100)}%;
      height: 100%;
      background: ${color};
      transition: width 0.3s ease;
    `;
  }
  /**
   * 渲染写作趋势图
   * Render writing trend chart
   */
  renderTrendChart(canvas, stats) {
    const container = canvas.parentElement;
    container.removeChild(canvas);
    const title = this.createElement("h4", "chart-title", container);
    title.textContent = "\u{1F4CA} \u5199\u4F5C\u8D8B\u52BF";
    title.style.cssText = "margin: 0 0 15px 0; text-align: center; color: var(--text-accent);";
    const trendContainer = this.createElement("div", "trend-display", container);
    trendContainer.style.cssText = `
      display: flex;
      justify-content: space-around;
      align-items: end;
      height: 150px;
      padding: 20px;
      border-bottom: 1px solid var(--background-modifier-border);
      position: relative;
    `;
    const weekData = [
      { day: "\u5468\u4E00", words: Math.floor(Math.random() * 1e3) + 500 },
      { day: "\u5468\u4E8C", words: Math.floor(Math.random() * 1e3) + 600 },
      { day: "\u5468\u4E09", words: Math.floor(Math.random() * 1e3) + 400 },
      { day: "\u5468\u56DB", words: Math.floor(Math.random() * 1e3) + 800 },
      { day: "\u5468\u4E94", words: Math.floor(Math.random() * 1e3) + 700 },
      { day: "\u5468\u516D", words: Math.floor(Math.random() * 1e3) + 900 },
      { day: "\u5468\u65E5", words: stats.todayWords || 300 }
    ];
    const maxWords = Math.max(...weekData.map((d) => d.words));
    weekData.forEach((data, index) => {
      const barContainer = this.createElement("div", "trend-bar-container", trendContainer);
      barContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
      `;
      const bar = this.createElement("div", "trend-bar", barContainer);
      const height = data.words / maxWords * 100;
      bar.style.cssText = `
        width: 20px;
        height: ${height}px;
        background: linear-gradient(to top, #4CAF50, #81C784);
        border-radius: 2px;
        position: relative;
      `;
      const label = this.createElement("div", "trend-label", barContainer);
      label.textContent = data.day;
      label.style.cssText = "font-size: 10px; color: var(--text-muted);";
      const value = this.createElement("div", "trend-value", barContainer);
      value.textContent = data.words.toString();
      value.style.cssText = "font-size: 9px; color: var(--text-muted);";
    });
  }
  /**
   * 渲染图表占位符
   * Render charts placeholder
   */
  renderChartsPlaceholder(container) {
    container.innerHTML = "";
    const placeholder = this.createElement("div", "charts-placeholder", container);
    placeholder.style.cssText = `
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: var(--text-muted);
      text-align: center;
    `;
    const icon = this.createElement("div", "", placeholder);
    icon.textContent = "\u{1F4CA}";
    icon.style.cssText = "font-size: 48px; margin-bottom: 10px;";
    const text = this.createElement("div", "", placeholder);
    text.textContent = "\u7EDF\u8BA1\u56FE\u8868";
    text.style.cssText = "font-size: 16px; font-weight: 500;";
    const desc = this.createElement("div", "", placeholder);
    desc.textContent = "\u9879\u76EE\u6570\u636E\u52A0\u8F7D\u5B8C\u6210\u540E\u5C06\u663E\u793A\u8BE6\u7EC6\u56FE\u8868";
    desc.style.cssText = "font-size: 12px; margin-top: 5px;";
  }
  /**
   * 渲染简单统计信息
   * Render simple statistics instead of charts
   */
  renderSimpleStats(container) {
    try {
      const stats = this.projectService.getProjectStats();
      const simpleStatsContainer = this.createElement("div", "simple-stats", container);
      simpleStatsContainer.style.cssText = `
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin: 20px 0;
      `;
      const chapterStats = this.createElement("div", "chapter-stats", simpleStatsContainer);
      chapterStats.style.cssText = `
        padding: 15px;
        background: var(--background-primary);
        border-radius: 6px;
        border: 1px solid var(--background-modifier-border);
      `;
      const chapterTitle = this.createElement("h4", "", chapterStats);
      chapterTitle.textContent = "\u{1F4DA} \u7AE0\u8282\u7EDF\u8BA1";
      chapterTitle.style.cssText = "margin: 0 0 10px 0; font-size: 14px; color: var(--text-accent);";
      const chapterCount = this.createElement("div", "", chapterStats);
      chapterCount.textContent = `\u5171 ${stats.chapterCount} \u7AE0`;
      chapterCount.style.cssText = "font-size: 16px; font-weight: 500;";
      const sceneStats = this.createElement("div", "scene-stats", simpleStatsContainer);
      sceneStats.style.cssText = `
        padding: 15px;
        background: var(--background-primary);
        border-radius: 6px;
        border: 1px solid var(--background-modifier-border);
      `;
      const sceneTitle = this.createElement("h4", "", sceneStats);
      sceneTitle.textContent = "\u{1F3AC} \u573A\u666F\u7EDF\u8BA1";
      sceneTitle.style.cssText = "margin: 0 0 10px 0; font-size: 14px; color: var(--text-accent);";
      const sceneCount = this.createElement("div", "", sceneStats);
      sceneCount.textContent = `\u5171 ${stats.sceneCount} \u4E2A\u573A\u666F`;
      sceneCount.style.cssText = "font-size: 16px; font-weight: 500;";
      const characterStats = this.createElement("div", "character-stats", simpleStatsContainer);
      characterStats.style.cssText = `
        padding: 15px;
        background: var(--background-primary);
        border-radius: 6px;
        border: 1px solid var(--background-modifier-border);
      `;
      const characterTitle = this.createElement("h4", "", characterStats);
      characterTitle.textContent = "\u{1F465} \u89D2\u8272\u7EDF\u8BA1";
      characterTitle.style.cssText = "margin: 0 0 10px 0; font-size: 14px; color: var(--text-accent);";
      const characterCount = this.createElement("div", "", characterStats);
      characterCount.textContent = `\u5171 ${stats.characterCount} \u4E2A\u89D2\u8272`;
      characterCount.style.cssText = "font-size: 16px; font-weight: 500;";
    } catch (error) {
      console.error("Failed to render simple stats:", error);
      const errorMsg = this.createElement("div", "stats-error", container);
      errorMsg.textContent = "\u7EDF\u8BA1\u4FE1\u606F\u6682\u65F6\u65E0\u6CD5\u663E\u793A";
      errorMsg.style.cssText = `
        padding: 20px;
        text-align: center;
        color: var(--text-muted);
        background: var(--background-secondary);
        border-radius: 6px;
        margin: 20px 0;
      `;
    }
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  onunload() {
    super.onunload();
  }
};

// src/services/ImmersiveWritingService.ts
var import_obsidian4 = require("obsidian");
var ImmersiveWritingService = class {
  constructor(app, projectService) {
    /** 当前合并的章节数据 */
    this.currentMergedChapter = null;
    /** 虚拟文档的编辑器引用 */
    this.virtualEditor = null;
    /** 场景内容映射 (用于实时同步) */
    this.sceneContentMap = /* @__PURE__ */ new Map();
    /** 编辑监听器 */
    this.editListeners = [];
    /** 上次检查的内容哈希 */
    this.lastContentHash = "";
    /** 同步状态 */
    this.isSyncing = false;
    this.syncTimeout = null;
    this.app = app;
    this.projectService = projectService;
  }
  /**
   * 合并章节内容创建虚拟文档
   * Merge chapter content to create virtual document
   */
  async mergeChapterForReading(chapterPath) {
    try {
      const scenes = await this.collectChapterScenes(chapterPath);
      if (scenes.length === 0) {
        throw new Error(`No scenes found in chapter: ${chapterPath}`);
      }
      scenes.sort((a, b) => a.sceneIndex - b.sceneIndex);
      const mergedContent = await this.generateMergedContent(scenes);
      this.currentMergedChapter = {
        chapterPath,
        scenes,
        content: mergedContent,
        lastModified: new Date()
      };
      this.sceneContentMap.clear();
      await this.buildSceneContentMap(scenes, mergedContent);
      return mergedContent;
    } catch (error) {
      console.error("Failed to merge chapter for reading:", error);
      throw error;
    }
  }
  /**
   * 创建虚拟文档并打开编辑器
   * Create virtual document and open editor
   */
  async openMergedChapterEditor(chapterPath) {
    var _a;
    try {
      const mergedContent = await this.mergeChapterForReading(chapterPath);
      const tempFileName = `_merged_${this.getChapterName(chapterPath)}.md`;
      const tempFilePath = `${(_a = this.projectService.currentProject) == null ? void 0 : _a.rootPath}/${tempFileName}`;
      const existingFile = this.app.vault.getAbstractFileByPath(tempFilePath);
      if (existingFile) {
        await this.app.vault.delete(existingFile);
      }
      const tempFile = await this.app.vault.create(tempFilePath, mergedContent);
      const leaf = this.app.workspace.getLeaf(true);
      await leaf.openFile(tempFile);
      if (leaf.view instanceof import_obsidian4.MarkdownView) {
        this.virtualEditor = leaf.view.editor;
        this.setupEditListeners(leaf);
        this.addDocumentHeader(leaf);
      }
      console.log(`Merged chapter opened for editing: ${chapterPath}`);
    } catch (error) {
      console.error("Failed to open merged chapter editor:", error);
      throw error;
    }
  }
  /**
   * 收集章节下的所有场景文件
   * Collect all scene files under a chapter
   */
  async collectChapterScenes(chapterPath) {
    const scenes = [];
    const allScenes = this.projectService.getAllScenes();
    for (const scene of allScenes) {
      if (scene.path.startsWith(chapterPath)) {
        scenes.push(scene);
      }
    }
    return scenes;
  }
  /**
   * 生成合并后的内容
   * Generate merged content from scenes
   */
  async generateMergedContent(scenes) {
    const contentParts = [];
    const chapterName = this.extractChapterNameFromScenes(scenes);
    contentParts.push(`# ${chapterName}

`);
    contentParts.push(`> \u8FD9\u662F\u4E00\u4E2A\u5408\u5E76\u7684\u7AE0\u8282\u89C6\u56FE\uFF0C\u5305\u542B ${scenes.length} \u4E2A\u573A\u666F\u3002\u7F16\u8F91\u5185\u5BB9\u5C06\u81EA\u52A8\u540C\u6B65\u5230\u5BF9\u5E94\u7684\u6E90\u6587\u4EF6\u3002

`);
    contentParts.push(`---

`);
    for (const scene of scenes) {
      const file = this.app.vault.getAbstractFileByPath(scene.path);
      if (!file) {
        console.warn(`Scene file not found: ${scene.path}`);
        continue;
      }
      try {
        const content = await this.app.vault.read(file);
        const contentWithoutFrontmatter = this.removeFrontmatter(content);
        contentParts.push(`<!-- SCENE_START: ${scene.path} -->
`);
        contentParts.push(`## ${scene.title}

`);
        contentParts.push(contentWithoutFrontmatter);
        contentParts.push(`
<!-- SCENE_END: ${scene.path} -->

`);
      } catch (error) {
        console.error(`Failed to read scene file: ${scene.path}`, error);
        contentParts.push(`<!-- ERROR: Failed to load scene ${scene.path} -->

`);
      }
    }
    return contentParts.join("");
  }
  /**
   * 构建场景内容映射
   * Build scene content mapping for real-time sync
   */
  async buildSceneContentMap(scenes, mergedContent) {
    this.sceneContentMap.clear();
    await this.rebuildSceneContentMap(mergedContent);
  }
  /**
   * 重新构建场景内容映射
   * Rebuild scene content mapping
   */
  async rebuildSceneContentMap(mergedContent) {
    const lines = mergedContent.split("\n");
    let currentScenePath = null;
    let sceneStartLine = -1;
    let sceneEndLine = -1;
    this.sceneContentMap.clear();
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const sceneStartMatch = line.match(/<!-- SCENE_START: (.+) -->/);
      if (sceneStartMatch) {
        currentScenePath = sceneStartMatch[1];
        sceneStartLine = i;
        continue;
      }
      const sceneEndMatch = line.match(/<!-- SCENE_END: (.+) -->/);
      if (sceneEndMatch && currentScenePath === sceneEndMatch[1]) {
        sceneEndLine = i;
        this.sceneContentMap.set(currentScenePath, {
          scenePath: currentScenePath,
          startLine: sceneStartLine,
          endLine: sceneEndLine,
          originalContent: lines.slice(sceneStartLine + 2, sceneEndLine).join("\n")
          // 跳过标题行
        });
        currentScenePath = null;
        sceneStartLine = -1;
        sceneEndLine = -1;
      }
    }
  }
  /**
   * 设置编辑监听器
   * Setup edit listeners for real-time sync
   */
  setupEditListeners(leaf) {
    if (!this.virtualEditor)
      return;
    this.updateContentHash();
    const checkForChanges = () => {
      if (this.hasContentChanged()) {
        this.debounceSync(() => {
          this.syncChangesToSourceFiles();
        }, 1e3);
      }
    };
    const changeCheckInterval = setInterval(checkForChanges, 1e3);
    this.editListeners.push(() => {
      clearInterval(changeCheckInterval);
    });
    const activeLeafChangeListener = (activeLeaf) => {
      if (activeLeaf !== leaf) {
        this.syncChangesToSourceFiles().finally(() => {
          this.cleanupMergedSession();
        });
      }
    };
    this.app.workspace.on("active-leaf-change", activeLeafChangeListener);
    this.editListeners.push(() => {
      this.app.workspace.off("active-leaf-change", activeLeafChangeListener);
    });
    const saveListener = () => {
      this.syncChangesToSourceFiles();
    };
    const saveCheckInterval = setInterval(() => {
      if (this.virtualEditor && this.hasContentChanged()) {
        this.debounceSync(saveListener, 500);
      }
    }, 500);
    this.editListeners.push(() => {
      clearInterval(saveCheckInterval);
    });
  }
  /**
   * 同步更改到源文件
   * Sync changes to source files
   */
  async syncChangesToSourceFiles() {
    if (!this.virtualEditor || !this.currentMergedChapter || this.isSyncing) {
      return;
    }
    this.isSyncing = true;
    try {
      const currentContent = this.virtualEditor.getValue();
      const lines = currentContent.split("\n");
      await this.rebuildSceneContentMap(currentContent);
      for (const [scenePath, contentInfo] of this.sceneContentMap.entries()) {
        const currentSceneContent = lines.slice(
          contentInfo.startLine + 2,
          // 跳过场景标记和标题
          contentInfo.endLine
        ).join("\n");
        if (currentSceneContent !== contentInfo.originalContent) {
          await this.updateSceneFile(scenePath, currentSceneContent);
          contentInfo.originalContent = currentSceneContent;
          console.log(`Synced changes to scene: ${scenePath}`);
        }
      }
      this.updateContentHash();
    } catch (error) {
      console.error("Failed to sync changes to source files:", error);
    } finally {
      this.isSyncing = false;
    }
  }
  /**
   * 更新场景文件内容
   * Update scene file content
   */
  async updateSceneFile(scenePath, newContent) {
    try {
      const file = this.app.vault.getAbstractFileByPath(scenePath);
      if (!file) {
        console.error(`Scene file not found: ${scenePath}`);
        return;
      }
      const originalContent = await this.app.vault.read(file);
      const frontmatterMatch = originalContent.match(/^---\n([\s\S]*?)\n---\n/);
      const frontmatter = frontmatterMatch ? frontmatterMatch[0] : "";
      const cleanedContent = newContent.trim();
      const updatedContent = frontmatter + (cleanedContent ? cleanedContent + "\n" : "");
      if (updatedContent !== originalContent) {
        await this.app.vault.modify(file, updatedContent);
        await this.updateSceneWordCount(scenePath, cleanedContent);
        console.log(`Scene file updated: ${scenePath}`);
      }
    } catch (error) {
      console.error(`Failed to update scene file: ${scenePath}`, error);
      throw error;
    }
  }
  /**
   * 更新场景字数统计
   * Update scene word count
   */
  async updateSceneWordCount(scenePath, content) {
    try {
      const wordCount = content.replace(/\s+/g, "").length;
      const sceneData = this.projectService.getSceneData(scenePath);
      if (sceneData) {
        await this.projectService.updateSceneMetadata(scenePath, {
          wordCount,
          lastModified: new Date()
        });
      }
    } catch (error) {
      console.warn(`Failed to update word count for scene: ${scenePath}`, error);
    }
  }
  /**
   * 添加文档头部信息
   * Add document header information
   */
  addDocumentHeader(leaf) {
    if (!this.currentMergedChapter)
      return;
    const headerInfo = `\u5408\u5E76\u7AE0\u8282\u7F16\u8F91\u6A21\u5F0F - ${this.currentMergedChapter.scenes.length} \u4E2A\u573A\u666F`;
    console.log(headerInfo);
    this.addSyncStatusIndicator(leaf);
  }
  /**
   * 添加同步状态指示器
   * Add sync status indicator
   */
  addSyncStatusIndicator(leaf) {
    const statusEl = document.createElement("div");
    statusEl.className = "story-weaver-sync-status";
    statusEl.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--background-secondary);
      border: 1px solid var(--background-modifier-border);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      z-index: 1000;
      opacity: 0.8;
    `;
    statusEl.textContent = "\u81EA\u52A8\u540C\u6B65\u5DF2\u542F\u7528";
    document.body.appendChild(statusEl);
    this.editListeners.push(() => {
      if (statusEl.parentNode) {
        statusEl.parentNode.removeChild(statusEl);
      }
    });
  }
  /**
   * 获取当前同步状态
   * Get current sync status
   */
  getSyncStatus() {
    return {
      isActive: this.currentMergedChapter !== null,
      isSyncing: this.isSyncing,
      sceneCount: this.sceneContentMap.size
    };
  }
  /**
   * 清理合并会话
   * Cleanup merged session
   */
  cleanupMergedSession() {
    this.editListeners.forEach((cleanup) => cleanup());
    this.editListeners = [];
    if (this.currentMergedChapter && this.projectService.currentProject) {
      const tempFileName = `_merged_${this.getChapterName(this.currentMergedChapter.chapterPath)}.md`;
      const tempFilePath = `${this.projectService.currentProject.rootPath}/${tempFileName}`;
      const tempFile = this.app.vault.getAbstractFileByPath(tempFilePath);
      if (tempFile) {
        try {
          this.app.vault.delete(tempFile);
        } catch (error) {
          console.warn("Failed to delete temporary file:", error);
        }
      }
    }
    this.currentMergedChapter = null;
    this.virtualEditor = null;
    this.sceneContentMap.clear();
    console.log("Merged session cleaned up");
  }
  /**
   * 移除 frontmatter
   * Remove YAML frontmatter from content
   */
  removeFrontmatter(content) {
    const frontmatterMatch = content.match(/^---\n[\s\S]*?\n---\n/);
    if (frontmatterMatch) {
      return content.substring(frontmatterMatch[0].length);
    }
    return content;
  }
  /**
   * 获取章节名称
   * Get chapter name from path
   */
  getChapterName(chapterPath) {
    const pathParts = chapterPath.split("/");
    return pathParts[pathParts.length - 1] || "Unknown Chapter";
  }
  /**
   * 从场景路径提取章节名称
   * Extract chapter name from scene path
   */
  extractChapterNameFromScenes(scenes) {
    if (scenes.length === 0)
      return "Unknown Chapter";
    const firstScenePath = scenes[0].path;
    const pathParts = firstScenePath.split("/");
    if (pathParts.length >= 2) {
      return pathParts[pathParts.length - 2];
    }
    return "Unknown Chapter";
  }
  /**
   * 检查内容是否发生变化
   * Check if content has changed
   */
  hasContentChanged() {
    if (!this.virtualEditor)
      return false;
    const currentContent = this.virtualEditor.getValue();
    const currentHash = this.hashContent(currentContent);
    return currentHash !== this.lastContentHash;
  }
  /**
   * 更新内容哈希
   * Update content hash
   */
  updateContentHash() {
    if (!this.virtualEditor)
      return;
    const currentContent = this.virtualEditor.getValue();
    this.lastContentHash = this.hashContent(currentContent);
  }
  /**
   * 计算内容哈希
   * Calculate content hash
   */
  hashContent(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  /**
   * 防抖同步函数
   * Debounced sync function
   */
  debounceSync(fn, delay) {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
    }
    this.syncTimeout = setTimeout(fn, delay);
  }
  /**
   * 销毁服务
   * Destroy service and cleanup resources
   */
  destroy() {
    this.cleanupMergedSession();
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout);
      this.syncTimeout = null;
    }
  }
};

// src/views/SceneInfoPanel.ts
var import_obsidian5 = require("obsidian");

// src/services/SuggestionHelper.ts
var SuggestionHelper = class {
  constructor(app, projectService) {
    this.app = app;
    this.projectService = projectService;
  }
  /**
   * 为输入框设置角色自动建议
   * Setup character auto-suggestion for input element
   */
  setupCharacterSuggestion(inputEl) {
    this.setupAutoSuggestion(inputEl, () => this.getCharacterSuggestions());
  }
  /**
   * 为输入框设置地点自动建议
   * Setup location auto-suggestion for input element
   */
  setupLocationSuggestion(inputEl) {
    this.setupAutoSuggestion(inputEl, () => this.getLocationSuggestions());
  }
  /**
   * 获取角色建议列表
   * Get character suggestions
   */
  getCharacterSuggestions() {
    const characters = this.projectService.getAllCharacters();
    return characters.map((char) => char.name).filter((name) => name && name.trim()).sort();
  }
  /**
   * 获取地点建议列表
   * Get location suggestions
   */
  getLocationSuggestions() {
    const locations = this.projectService.getAllLocations();
    return locations.map((loc) => loc.name).filter((name) => name && name.trim()).sort();
  }
  /**
   * 为输入框设置通用自动建议功能
   * Setup generic auto-suggestion for input element
   */
  setupAutoSuggestion(inputEl, getSuggestions) {
    let suggestionContainer = null;
    let currentSuggestions = [];
    let selectedIndex = -1;
    const createSuggestionContainer = () => {
      const container = document.createElement("div");
      container.className = "story-weaver-suggestion-container";
      container.style.position = "absolute";
      container.style.zIndex = "1000";
      container.style.backgroundColor = "var(--background-primary)";
      container.style.border = "1px solid var(--background-modifier-border)";
      container.style.borderRadius = "4px";
      container.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
      container.style.maxHeight = "200px";
      container.style.overflowY = "auto";
      container.style.display = "none";
      const rect = inputEl.getBoundingClientRect();
      container.style.top = `${rect.bottom + window.scrollY}px`;
      container.style.left = `${rect.left + window.scrollX}px`;
      container.style.width = `${rect.width}px`;
      document.body.appendChild(container);
      return container;
    };
    const showSuggestions = (suggestions) => {
      if (!suggestionContainer) {
        suggestionContainer = createSuggestionContainer();
      }
      suggestionContainer.innerHTML = "";
      currentSuggestions = suggestions;
      selectedIndex = -1;
      if (suggestions.length === 0) {
        suggestionContainer.style.display = "none";
        return;
      }
      suggestions.forEach((suggestion, index) => {
        const item = document.createElement("div");
        item.className = "story-weaver-suggestion-item";
        item.textContent = suggestion;
        item.style.padding = "8px 12px";
        item.style.cursor = "pointer";
        item.style.borderBottom = "1px solid var(--background-modifier-border-hover)";
        item.addEventListener("mouseenter", () => {
          selectedIndex = index;
          updateSelection();
        });
        item.addEventListener("click", () => {
          selectSuggestion(suggestion);
        });
        suggestionContainer.appendChild(item);
      });
      suggestionContainer.style.display = "block";
      updateSelection();
    };
    const hideSuggestions = () => {
      if (suggestionContainer) {
        suggestionContainer.style.display = "none";
      }
      selectedIndex = -1;
    };
    const updateSelection = () => {
      if (!suggestionContainer)
        return;
      const items = suggestionContainer.querySelectorAll(".story-weaver-suggestion-item");
      items.forEach((item, index) => {
        if (index === selectedIndex) {
          item.style.backgroundColor = "var(--background-modifier-hover)";
        } else {
          item.style.backgroundColor = "transparent";
        }
      });
    };
    const selectSuggestion = (suggestion) => {
      inputEl.value = suggestion;
      inputEl.dispatchEvent(new Event("input", { bubbles: true }));
      inputEl.dispatchEvent(new Event("change", { bubbles: true }));
      hideSuggestions();
      inputEl.focus();
    };
    const filterSuggestions = (query) => {
      if (!query.trim()) {
        return getSuggestions().slice(0, 10);
      }
      const lowerQuery = query.toLowerCase();
      return getSuggestions().filter(
        (suggestion) => suggestion.toLowerCase().includes(lowerQuery)
      ).slice(0, 10);
    };
    inputEl.addEventListener("input", (e) => {
      const query = e.target.value;
      const suggestions = filterSuggestions(query);
      showSuggestions(suggestions);
    });
    inputEl.addEventListener("focus", () => {
      const query = inputEl.value;
      const suggestions = filterSuggestions(query);
      showSuggestions(suggestions);
    });
    inputEl.addEventListener("keydown", (e) => {
      if (!suggestionContainer || suggestionContainer.style.display === "none") {
        return;
      }
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          selectedIndex = Math.min(selectedIndex + 1, currentSuggestions.length - 1);
          updateSelection();
          break;
        case "ArrowUp":
          e.preventDefault();
          selectedIndex = Math.max(selectedIndex - 1, -1);
          updateSelection();
          break;
        case "Enter":
          e.preventDefault();
          if (selectedIndex >= 0 && selectedIndex < currentSuggestions.length) {
            selectSuggestion(currentSuggestions[selectedIndex]);
          }
          break;
        case "Escape":
          e.preventDefault();
          hideSuggestions();
          break;
      }
    });
    document.addEventListener("click", (e) => {
      if (!inputEl.contains(e.target) && !(suggestionContainer == null ? void 0 : suggestionContainer.contains(e.target))) {
        hideSuggestions();
      }
    });
    const cleanup = () => {
      if (suggestionContainer) {
        suggestionContainer.remove();
        suggestionContainer = null;
      }
    };
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node.contains && node.contains(inputEl)) {
            cleanup();
            observer.disconnect();
          }
        });
      });
    });
    observer.observe(document.body, { childList: true, subtree: true });
  }
  /**
   * 验证角色引用
   * Validate character reference
   */
  validateCharacterReference(characterName) {
    if (!characterName.trim()) {
      return { isValid: true };
    }
    const characters = this.getCharacterSuggestions();
    const exactMatch = characters.find(
      (char) => char.toLowerCase() === characterName.toLowerCase()
    );
    if (exactMatch) {
      return { isValid: true };
    }
    const similarCharacter = characters.find(
      (char) => char.toLowerCase().includes(characterName.toLowerCase()) || characterName.toLowerCase().includes(char.toLowerCase())
    );
    if (similarCharacter) {
      return {
        isValid: false,
        suggestion: similarCharacter,
        error: `\u89D2\u8272 "${characterName}" \u4E0D\u5B58\u5728\uFF0C\u60A8\u662F\u5426\u60F3\u8981 "${similarCharacter}"\uFF1F`
      };
    }
    return {
      isValid: false,
      error: `\u89D2\u8272 "${characterName}" \u4E0D\u5B58\u5728`
    };
  }
  /**
   * 验证地点引用
   * Validate location reference
   */
  validateLocationReference(locationName) {
    if (!locationName.trim()) {
      return { isValid: true };
    }
    const locations = this.getLocationSuggestions();
    const exactMatch = locations.find(
      (loc) => loc.toLowerCase() === locationName.toLowerCase()
    );
    if (exactMatch) {
      return { isValid: true };
    }
    const similarLocation = locations.find(
      (loc) => loc.toLowerCase().includes(locationName.toLowerCase()) || locationName.toLowerCase().includes(loc.toLowerCase())
    );
    if (similarLocation) {
      return {
        isValid: false,
        suggestion: similarLocation,
        error: `\u5730\u70B9 "${locationName}" \u4E0D\u5B58\u5728\uFF0C\u60A8\u662F\u5426\u60F3\u8981 "${similarLocation}"\uFF1F`
      };
    }
    return {
      isValid: false,
      error: `\u5730\u70B9 "${locationName}" \u4E0D\u5B58\u5728`
    };
  }
  /**
   * 验证故事时间格式
   * Validate story time format
   */
  validateStoryTime(timeString) {
    if (!timeString.trim()) {
      return { isValid: true };
    }
    const formats = [
      /^\d{4}-\d{2}-\d{2}$/,
      // YYYY-MM-DD
      /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/,
      // YYYY-MM-DD HH:mm
      /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/
      // YYYY-MM-DD HH:mm:ss
    ];
    const isValidFormat = formats.some((format) => format.test(timeString));
    if (!isValidFormat) {
      return {
        isValid: false,
        error: "\u65F6\u95F4\u683C\u5F0F\u4E0D\u6B63\u786E\uFF0C\u8BF7\u4F7F\u7528 YYYY-MM-DD \u6216 YYYY-MM-DD HH:mm \u683C\u5F0F"
      };
    }
    const parsedDate = new Date(timeString);
    if (isNaN(parsedDate.getTime())) {
      return {
        isValid: false,
        error: "\u65E0\u6548\u7684\u65E5\u671F\u65F6\u95F4"
      };
    }
    return {
      isValid: true,
      parsedDate
    };
  }
  /**
   * 验证场景标题
   * Validate scene title
   */
  validateSceneTitle(title) {
    if (!title.trim()) {
      return {
        isValid: false,
        error: "\u573A\u666F\u6807\u9898\u4E0D\u80FD\u4E3A\u7A7A"
      };
    }
    if (title.length > 100) {
      return {
        isValid: false,
        error: "\u573A\u666F\u6807\u9898\u4E0D\u80FD\u8D85\u8FC7100\u4E2A\u5B57\u7B26"
      };
    }
    return { isValid: true };
  }
  /**
   * 验证场景梗概
   * Validate scene synopsis
   */
  validateSceneSynopsis(synopsis) {
    if (synopsis.length > 500) {
      return {
        isValid: false,
        error: "\u573A\u666F\u6897\u6982\u4E0D\u80FD\u8D85\u8FC7500\u4E2A\u5B57\u7B26"
      };
    }
    if (synopsis.trim() && synopsis.length < 10) {
      return {
        isValid: true,
        warning: "\u5EFA\u8BAE\u6897\u6982\u81F3\u5C11\u5305\u542B10\u4E2A\u5B57\u7B26\u4EE5\u4FBF\u66F4\u597D\u5730\u63CF\u8FF0\u573A\u666F"
      };
    }
    return { isValid: true };
  }
};

// src/views/SceneInfoPanel.ts
var _SceneInfoPanel = class extends import_obsidian5.ItemView {
  constructor(leaf, projectService) {
    super(leaf);
    /** 当前场景数据 */
    this.currentScene = null;
    /** 当前活动文件 */
    this.currentFile = null;
    /** 表单容器元素 */
    this.formContainer = null;
    /** 验证错误状态 */
    this.validationErrors = /* @__PURE__ */ new Map();
    this.projectService = projectService;
    this.suggestionHelper = new SuggestionHelper(this.app, projectService);
  }
  /**
   * 获取视图类型
   * Get view type
   */
  getViewType() {
    return _SceneInfoPanel.VIEW_TYPE;
  }
  /**
   * 获取视图显示名称
   * Get view display text
   */
  getDisplayText() {
    return "\u573A\u666F\u4FE1\u606F";
  }
  /**
   * 获取视图图标
   * Get view icon
   */
  getIcon() {
    return "file-text";
  }
  /**
   * 视图打开时调用
   * Called when view is opened
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("story-weaver-scene-info-panel");
    const titleEl = container.createEl("div", { cls: "scene-info-title" });
    titleEl.createEl("h3", { text: "\u573A\u666F\u4FE1\u606F" });
    this.formContainer = container.createEl("div", { cls: "scene-info-form" });
    this.renderSceneForm();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.updateCurrentScene();
      })
    );
    this.updateCurrentScene();
  }
  /**
   * 视图关闭时调用
   * Called when view is closed
   */
  async onClose() {
    this.currentScene = null;
    this.currentFile = null;
    this.formContainer = null;
  }
  /**
   * 更新当前场景
   * Update current scene based on active file
   */
  updateCurrentScene() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      this.setCurrentScene(null, null);
      return;
    }
    if (this.isSceneFile(activeFile)) {
      const sceneData = this.projectService.getSceneData(activeFile.path);
      this.setCurrentScene(activeFile, sceneData || null);
    } else {
      this.setCurrentScene(null, null);
    }
  }
  /**
   * 设置当前场景
   * Set current scene
   */
  setCurrentScene(file, scene) {
    this.currentFile = file;
    this.currentScene = scene;
    this.renderSceneForm();
  }
  /**
   * 检查文件是否为场景文件
   * Check if file is a scene file
   */
  isSceneFile(file) {
    if (!this.projectService.currentProject) {
      return false;
    }
    const scenesPath = `${this.projectService.currentProject.rootPath}/10_\u7A3F\u4EF6`;
    return file.path.startsWith(scenesPath);
  }
  /**
   * 渲染场景表单
   * Render scene form
   */
  renderSceneForm() {
    if (!this.formContainer) {
      return;
    }
    this.formContainer.empty();
    if (!this.currentScene || !this.currentFile) {
      this.renderEmptyState();
      return;
    }
    this.renderFormFields();
  }
  /**
   * 渲染空状态
   * Render empty state
   */
  renderEmptyState() {
    if (!this.formContainer)
      return;
    const emptyState = this.formContainer.createEl("div", { cls: "scene-info-empty" });
    emptyState.createEl("p", {
      text: "\u8BF7\u9009\u62E9\u4E00\u4E2A\u573A\u666F\u6587\u4EF6\u4EE5\u7F16\u8F91\u573A\u666F\u4FE1\u606F",
      cls: "scene-info-empty-text"
    });
  }
  /**
   * 渲染表单字段
   * Render form fields
   */
  renderFormFields() {
    if (!this.formContainer || !this.currentScene)
      return;
    this.renderTitleField();
    this.renderStatusField();
    this.renderPovField();
    this.renderLocationField();
    this.renderStoryTimeField();
    this.renderSynopsisField();
    this.renderWordCountField();
    this.renderTagsField();
  }
  /**
   * 渲染标题字段
   * Render title field
   */
  renderTitleField() {
    if (!this.formContainer || !this.currentScene)
      return;
    const setting = new import_obsidian5.Setting(this.formContainer).setName("\u573A\u666F\u6807\u9898").setDesc("\u573A\u666F\u7684\u6807\u9898").addText((text) => {
      var _a;
      text.setPlaceholder("\u8F93\u5165\u573A\u666F\u6807\u9898").setValue(((_a = this.currentScene) == null ? void 0 : _a.title) || "").onChange(async (value) => {
        const validation = this.suggestionHelper.validateSceneTitle(value);
        this.updateFieldValidation("title", text.inputEl, validation);
        if (validation.isValid) {
          await this.updateSceneField("title", value);
        }
      });
    });
    this.addValidationMessage(setting.settingEl, "title");
  }
  /**
   * 渲染状态字段
   * Render status field
   */
  renderStatusField() {
    if (!this.formContainer || !this.currentScene)
      return;
    new import_obsidian5.Setting(this.formContainer).setName("\u573A\u666F\u72B6\u6001").setDesc("\u5F53\u524D\u573A\u666F\u7684\u5B8C\u6210\u72B6\u6001").addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("outline", "\u5927\u7EB2").addOption("draft", "\u8349\u7A3F").addOption("revised", "\u4FEE\u6539").addOption("complete", "\u5B8C\u6210").setValue(((_a = this.currentScene) == null ? void 0 : _a.status) || "outline").onChange(async (value) => {
        await this.updateSceneField("status", value);
      });
    });
  }
  /**
   * 渲染视角角色字段
   * Render POV character field
   */
  renderPovField() {
    if (!this.formContainer || !this.currentScene)
      return;
    const setting = new import_obsidian5.Setting(this.formContainer).setName("\u89C6\u89D2\u89D2\u8272").setDesc("\u573A\u666F\u7684\u89C6\u89D2\u89D2\u8272").addText((text) => {
      var _a;
      text.setPlaceholder("\u9009\u62E9\u6216\u8F93\u5165\u89D2\u8272\u540D\u79F0").setValue(((_a = this.currentScene) == null ? void 0 : _a.pov) || "").onChange(async (value) => {
        const validation = this.suggestionHelper.validateCharacterReference(value);
        this.updateFieldValidation("pov", text.inputEl, validation);
        if (validation.isValid) {
          await this.updateSceneField("pov", value);
        }
      });
      this.suggestionHelper.setupCharacterSuggestion(text.inputEl);
    });
    this.addValidationMessage(setting.settingEl, "pov");
  }
  /**
   * 渲染地点字段
   * Render location field
   */
  renderLocationField() {
    if (!this.formContainer || !this.currentScene)
      return;
    const setting = new import_obsidian5.Setting(this.formContainer).setName("\u53D1\u751F\u5730\u70B9").setDesc("\u573A\u666F\u53D1\u751F\u7684\u5730\u70B9").addText((text) => {
      var _a;
      text.setPlaceholder("\u9009\u62E9\u6216\u8F93\u5165\u5730\u70B9\u540D\u79F0").setValue(((_a = this.currentScene) == null ? void 0 : _a.location) || "").onChange(async (value) => {
        const validation = this.suggestionHelper.validateLocationReference(value);
        this.updateFieldValidation("location", text.inputEl, validation);
        if (validation.isValid) {
          await this.updateSceneField("location", value);
        }
      });
      this.suggestionHelper.setupLocationSuggestion(text.inputEl);
    });
    this.addValidationMessage(setting.settingEl, "location");
  }
  /**
   * 渲染故事时间字段
   * Render story time field
   */
  renderStoryTimeField() {
    var _a;
    if (!this.formContainer || !this.currentScene)
      return;
    const timeValue = ((_a = this.currentScene) == null ? void 0 : _a.storyTime) ? this.formatDateTime(this.currentScene.storyTime) : "";
    const setting = new import_obsidian5.Setting(this.formContainer).setName("\u6545\u4E8B\u65F6\u95F4").setDesc("\u573A\u666F\u5728\u6545\u4E8B\u4E2D\u53D1\u751F\u7684\u65F6\u95F4").addText((text) => {
      text.setPlaceholder("YYYY-MM-DD HH:mm").setValue(timeValue).onChange(async (value) => {
        const validation = this.suggestionHelper.validateStoryTime(value);
        this.updateFieldValidation("storyTime", text.inputEl, validation);
        if (validation.isValid) {
          const date = validation.parsedDate || null;
          await this.updateSceneField("storyTime", date);
        }
      });
    });
    this.addValidationMessage(setting.settingEl, "storyTime");
  }
  /**
   * 渲染梗概字段
   * Render synopsis field
   */
  renderSynopsisField() {
    if (!this.formContainer || !this.currentScene)
      return;
    const setting = new import_obsidian5.Setting(this.formContainer).setName("\u4E00\u53E5\u8BDD\u6897\u6982").setDesc("\u573A\u666F\u7684\u7B80\u8981\u63CF\u8FF0").addTextArea((text) => {
      var _a;
      text.setPlaceholder("\u8F93\u5165\u573A\u666F\u6897\u6982").setValue(((_a = this.currentScene) == null ? void 0 : _a.synopsis) || "").onChange(async (value) => {
        const validation = this.suggestionHelper.validateSceneSynopsis(value);
        this.updateFieldValidation("synopsis", text.inputEl, validation);
        if (validation.isValid) {
          await this.updateSceneField("synopsis", value);
        }
      });
      text.inputEl.rows = 3;
    });
    this.addValidationMessage(setting.settingEl, "synopsis");
  }
  /**
   * 渲染字数统计字段
   * Render word count field (read-only)
   */
  renderWordCountField() {
    if (!this.formContainer || !this.currentScene)
      return;
    new import_obsidian5.Setting(this.formContainer).setName("\u5B57\u6570\u7EDF\u8BA1").setDesc("\u5F53\u524D\u573A\u666F\u7684\u5B57\u6570").addText((text) => {
      var _a, _b;
      text.setValue(((_b = (_a = this.currentScene) == null ? void 0 : _a.wordCount) == null ? void 0 : _b.toString()) || "0").setDisabled(true);
    });
  }
  /**
   * 渲染标签字段
   * Render tags field
   */
  renderTagsField() {
    var _a, _b;
    if (!this.formContainer || !this.currentScene)
      return;
    const tagsValue = ((_b = (_a = this.currentScene) == null ? void 0 : _a.tags) == null ? void 0 : _b.join(", ")) || "";
    new import_obsidian5.Setting(this.formContainer).setName("\u6807\u7B7E").setDesc("\u573A\u666F\u6807\u7B7E\uFF0C\u7528\u9017\u53F7\u5206\u9694").addText((text) => {
      text.setPlaceholder("\u6807\u7B7E1, \u6807\u7B7E2, \u6807\u7B7E3").setValue(tagsValue).onChange(async (value) => {
        const tags = value.split(",").map((tag) => tag.trim()).filter((tag) => tag);
        await this.updateSceneField("tags", tags);
      });
    });
  }
  /**
   * 更新场景字段
   * Update scene field
   */
  async updateSceneField(field, value) {
    if (!this.currentScene || !this.currentFile) {
      return;
    }
    if (this.hasValidationErrors()) {
      console.warn("Cannot update scene field due to validation errors:", this.getValidationErrors());
      return;
    }
    try {
      const updateData = {
        [field]: value
      };
      await this.projectService.updateSceneMetadata(this.currentFile.path, updateData);
      this.currentScene = {
        ...this.currentScene,
        [field]: value,
        lastModified: new Date()
      };
      console.log(`Scene field updated: ${field} = ${value}`);
    } catch (error) {
      console.error(`Failed to update scene field ${field}:`, error);
      this.showErrorMessage(`\u66F4\u65B0\u573A\u666F\u4FE1\u606F\u5931\u8D25: ${error.message}`);
    }
  }
  /**
   * 显示错误消息
   * Show error message
   */
  showErrorMessage(message) {
    if (!this.formContainer)
      return;
    const errorEl = this.formContainer.createEl("div", {
      cls: "story-weaver-error-message",
      text: message
    });
    errorEl.style.cssText = `
      background: var(--background-modifier-error);
      color: var(--text-error);
      padding: 8px 12px;
      border-radius: 4px;
      margin: 8px 0;
      font-size: 0.9em;
      border: 1px solid var(--text-error);
    `;
    setTimeout(() => {
      errorEl.remove();
    }, 3e3);
  }
  /**
   * 添加验证消息容器
   * Add validation message container
   */
  addValidationMessage(settingEl, fieldName) {
    const messageEl = settingEl.createEl("div", {
      cls: "validation-message",
      attr: { "data-field": fieldName }
    });
    messageEl.style.display = "none";
  }
  /**
   * 更新字段验证状态
   * Update field validation state
   */
  updateFieldValidation(fieldName, inputEl, validation) {
    var _a;
    inputEl.classList.remove("field-error", "field-warning");
    const messageEl = (_a = this.formContainer) == null ? void 0 : _a.querySelector(
      `.validation-message[data-field="${fieldName}"]`
    );
    if (!messageEl)
      return;
    if (!validation.isValid && validation.error) {
      inputEl.classList.add("field-error");
      messageEl.className = "validation-message validation-error";
      messageEl.textContent = validation.error;
      messageEl.style.display = "block";
      this.validationErrors.set(fieldName, validation.error);
    } else if (validation.warning) {
      inputEl.classList.add("field-warning");
      messageEl.className = "validation-message validation-warning";
      messageEl.textContent = validation.warning;
      messageEl.style.display = "block";
      this.validationErrors.delete(fieldName);
    } else {
      messageEl.style.display = "none";
      messageEl.textContent = "";
      this.validationErrors.delete(fieldName);
    }
  }
  /**
   * 检查表单是否有验证错误
   * Check if form has validation errors
   */
  hasValidationErrors() {
    return this.validationErrors.size > 0;
  }
  /**
   * 获取所有验证错误
   * Get all validation errors
   */
  getValidationErrors() {
    return Array.from(this.validationErrors.values());
  }
  /**
   * 格式化日期时间
   * Format date time for display
   */
  formatDateTime(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hours = String(date.getHours()).padStart(2, "0");
    const minutes = String(date.getMinutes()).padStart(2, "0");
    return `${year}-${month}-${day} ${hours}:${minutes}`;
  }
};
var SceneInfoPanel = _SceneInfoPanel;
/** 视图类型标识符 */
SceneInfoPanel.VIEW_TYPE = "story-weaver-scene-info";

// src/views/OutlineView.ts
var import_obsidian6 = require("obsidian");
var _OutlineView = class extends import_obsidian6.ItemView {
  constructor(leaf, projectService) {
    super(leaf);
    /** 当前渲染的大纲数据 */
    this.outlineData = [];
    /** 拖拽状态 */
    this.isDragging = false;
    this.draggedElement = null;
    this.draggedSceneData = null;
    this.projectService = projectService;
  }
  /**
   * 获取视图类型
   * Get view type
   */
  getViewType() {
    return _OutlineView.VIEW_TYPE;
  }
  /**
   * 获取视图显示名称
   * Get view display text
   */
  getDisplayText() {
    return "\u7EC7\u6587\u8005\u5927\u7EB2";
  }
  /**
   * 获取视图图标
   * Get view icon
   */
  getIcon() {
    return "list-tree";
  }
  /**
   * 视图打开时调用
   * Called when view is opened
   */
  async onOpen() {
    console.log("OutlineView opened");
    if (!this.projectService.currentProject) {
      console.log("No project loaded, attempting auto-load...");
      await this.projectService.autoLoadProject();
    }
    this.renderOutline();
  }
  /**
   * 视图关闭时调用
   * Called when view is closed
   */
  async onClose() {
    console.log("OutlineView closed");
    this.cleanup();
  }
  /**
   * 刷新大纲视图
   * Refresh outline view
   */
  refresh() {
    this.renderOutline();
  }
  /**
   * 处理项目变更
   * Handle project change
   */
  onProjectChanged() {
    this.outlineData = [];
    this.renderOutline();
  }
  /**
   * 渲染大纲视图
   * Render outline view
   */
  renderOutline() {
    const container = this.containerEl;
    container.empty();
    if (!this.projectService.currentProject) {
      this.renderNoProjectMessage(container);
      return;
    }
    if (!this.projectService.isCacheInitialized()) {
      this.renderLoadingMessage(container);
      return;
    }
    this.buildOutlineData();
    this.renderOutlineTree(container);
  }
  /**
   * 渲染无项目消息
   * Render no project message
   */
  renderNoProjectMessage(container) {
    const messageEl = container.createDiv("outline-no-project");
    messageEl.createEl("h3", { text: "\u672A\u52A0\u8F7D\u9879\u76EE" });
    messageEl.createEl("p", { text: "\u8BF7\u5148\u521B\u5EFA\u6216\u52A0\u8F7D\u4E00\u4E2A\u5199\u4F5C\u9879\u76EE" });
    const createButton = messageEl.createEl("button", {
      text: "\u521B\u5EFA\u65B0\u9879\u76EE",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      this.app.commands.executeCommandById("story-weaver:create-new-project");
    });
  }
  /**
   * 渲染加载消息
   * Render loading message
   */
  renderLoadingMessage(container) {
    const messageEl = container.createDiv("outline-loading");
    messageEl.createEl("div", { text: "\u6B63\u5728\u52A0\u8F7D\u9879\u76EE\u6570\u636E...", cls: "loading-text" });
    const spinner = messageEl.createDiv("loading-spinner");
    spinner.innerHTML = "\u27F3";
  }
  /**
   * 构建大纲数据结构
   * Build outline data structure
   */
  buildOutlineData() {
    const scenes = this.projectService.getAllScenes();
    scenes.sort((a, b) => {
      if (a.chapterIndex !== b.chapterIndex) {
        return a.chapterIndex - b.chapterIndex;
      }
      return a.sceneIndex - b.sceneIndex;
    });
    const volumeMap = /* @__PURE__ */ new Map();
    const chapterMap = /* @__PURE__ */ new Map();
    for (const scene of scenes) {
      const pathParts = scene.path.split("/");
      let volumeIndex = 1;
      let volumeName = "\u7B2C\u4E00\u5377";
      if (pathParts.length >= 3) {
        const volumePart = pathParts[2];
        const volumeMatch = volumePart.match(/第(.+)卷/);
        if (volumeMatch) {
          volumeName = volumePart;
          const numMatch = volumeMatch[1].match(/\d+/);
          if (numMatch) {
            volumeIndex = parseInt(numMatch[0]);
          }
        }
      }
      if (!volumeMap.has(volumeIndex)) {
        volumeMap.set(volumeIndex, {
          type: "volume",
          index: volumeIndex,
          title: volumeName,
          chapters: [],
          isExpanded: true
        });
      }
      const volume = volumeMap.get(volumeIndex);
      const chapterKey = `${volumeIndex}-${scene.chapterIndex}`;
      if (!chapterMap.has(chapterKey)) {
        let chapterName = `\u7B2C${scene.chapterIndex}\u7AE0`;
        if (pathParts.length >= 4) {
          const chapterPart = pathParts[3];
          if (chapterPart.includes("\u7AE0")) {
            chapterName = chapterPart;
          }
        }
        const chapter2 = {
          type: "chapter",
          index: scene.chapterIndex,
          title: chapterName,
          scenes: [],
          isExpanded: true,
          volumeIndex
        };
        chapterMap.set(chapterKey, chapter2);
        volume.chapters.push(chapter2);
      }
      const chapter = chapterMap.get(chapterKey);
      const sceneNode = {
        type: "scene",
        data: scene,
        chapterIndex: scene.chapterIndex,
        volumeIndex
      };
      chapter.scenes.push(sceneNode);
    }
    this.outlineData = Array.from(volumeMap.values()).sort((a, b) => a.index - b.index);
    this.outlineData.forEach((volume) => {
      volume.chapters.sort((a, b) => a.index - b.index);
    });
  }
  /**
   * 渲染大纲树
   * Render outline tree
   */
  renderOutlineTree(container) {
    const outlineContainer = container.createDiv("outline-container");
    const headerEl = outlineContainer.createDiv("outline-header");
    headerEl.createEl("h3", { text: "\u9879\u76EE\u5927\u7EB2" });
    const statsEl = headerEl.createDiv("outline-stats");
    const totalScenes = this.projectService.getAllScenes().length;
    const totalChapters = this.outlineData.reduce((sum, volume) => sum + volume.chapters.length, 0);
    statsEl.createEl("span", { text: `${this.outlineData.length}\u5377 ${totalChapters}\u7AE0 ${totalScenes}\u573A\u666F` });
    const treeContainer = outlineContainer.createDiv("outline-tree");
    for (const volume of this.outlineData) {
      this.renderVolumeNode(treeContainer, volume);
    }
    if (this.outlineData.length === 0) {
      const emptyEl = treeContainer.createDiv("outline-empty");
      emptyEl.createEl("p", { text: "\u6682\u65E0\u7A3F\u4EF6\u5185\u5BB9" });
      emptyEl.createEl("p", { text: '\u8BF7\u5728 "10_\u7A3F\u4EF6" \u6587\u4EF6\u5939\u4E2D\u521B\u5EFA\u7AE0\u8282\u548C\u573A\u666F' });
    }
  }
  /**
   * 渲染卷节点
   * Render volume node
   */
  renderVolumeNode(container, volume) {
    const volumeEl = container.createDiv("outline-volume");
    const volumeHeader = volumeEl.createDiv("outline-volume-header");
    volumeHeader.setAttribute("data-volume-index", volume.index.toString());
    const expandIcon = volumeHeader.createSpan("outline-expand-icon");
    expandIcon.innerHTML = volume.isExpanded ? "\u25BC" : "\u25B6";
    expandIcon.addEventListener("click", () => {
      this.toggleVolumeExpansion(volume);
    });
    volumeHeader.setAttribute("tabindex", "0");
    volumeHeader.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.toggleVolumeExpansion(volume);
      }
    });
    const volumeTitle = volumeHeader.createSpan("outline-volume-title");
    volumeTitle.textContent = volume.title;
    const volumeStats = volumeHeader.createSpan("outline-volume-stats");
    const sceneCount = volume.chapters.reduce((sum, chapter) => sum + chapter.scenes.length, 0);
    volumeStats.textContent = `(${volume.chapters.length}\u7AE0 ${sceneCount}\u573A\u666F)`;
    if (volume.isExpanded) {
      const chaptersContainer = volumeEl.createDiv("outline-chapters");
      for (const chapter of volume.chapters) {
        this.renderChapterNode(chaptersContainer, chapter);
      }
    }
  }
  /**
   * 渲染章节节点
   * Render chapter node
   */
  renderChapterNode(container, chapter) {
    const chapterEl = container.createDiv("outline-chapter");
    const chapterHeader = chapterEl.createDiv("outline-chapter-header");
    chapterHeader.setAttribute("data-chapter-index", chapter.index.toString());
    chapterHeader.setAttribute("data-volume-index", chapter.volumeIndex.toString());
    const expandIcon = chapterHeader.createSpan("outline-expand-icon");
    expandIcon.innerHTML = chapter.isExpanded ? "\u25BC" : "\u25B6";
    expandIcon.addEventListener("click", () => {
      this.toggleChapterExpansion(chapter);
    });
    chapterHeader.setAttribute("tabindex", "0");
    chapterHeader.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.toggleChapterExpansion(chapter);
      }
    });
    const chapterTitle = chapterHeader.createSpan("outline-chapter-title");
    chapterTitle.textContent = chapter.title;
    const chapterStats = chapterHeader.createSpan("outline-chapter-stats");
    const wordCount = chapter.scenes.reduce((sum, scene) => sum + scene.data.wordCount, 0);
    chapterStats.textContent = `(${chapter.scenes.length}\u573A\u666F ${wordCount}\u5B57)`;
    if (chapter.isExpanded) {
      const scenesContainer = chapterEl.createDiv("outline-scenes");
      for (const scene of chapter.scenes) {
        this.renderSceneNode(scenesContainer, scene);
      }
    }
  }
  /**
   * 渲染场景节点
   * Render scene node
   */
  renderSceneNode(container, scene) {
    const sceneEl = container.createDiv("outline-scene");
    sceneEl.setAttribute("data-scene-path", scene.data.path);
    sceneEl.setAttribute("data-status", scene.data.status);
    sceneEl.setAttribute("draggable", "true");
    const statusIcon = sceneEl.createSpan("outline-scene-status");
    statusIcon.innerHTML = this.getStatusIcon(scene.data.status);
    statusIcon.setAttribute("title", this.getStatusText(scene.data.status));
    const sceneTitle = sceneEl.createSpan("outline-scene-title");
    sceneTitle.textContent = scene.data.title;
    const sceneInfo = sceneEl.createDiv("outline-scene-info");
    if (scene.data.wordCount > 0) {
      const wordCount = sceneInfo.createSpan("outline-scene-wordcount");
      wordCount.textContent = `${scene.data.wordCount}\u5B57`;
    }
    if (scene.data.synopsis) {
      const synopsis = sceneInfo.createSpan("outline-scene-synopsis");
      synopsis.textContent = scene.data.synopsis;
      synopsis.setAttribute("title", scene.data.synopsis);
    }
    sceneEl.addEventListener("click", () => {
      this.openSceneFile(scene.data);
    });
    sceneEl.setAttribute("tabindex", "0");
    sceneEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.openSceneFile(scene.data);
      }
    });
    this.addDragEvents(sceneEl, scene);
  }
  /**
   * 获取状态图标
   * Get status icon
   */
  getStatusIcon(status) {
    switch (status) {
      case "outline":
        return "\u25CB";
      case "draft":
        return "\u25D0";
      case "revised":
        return "\u25D1";
      case "complete":
        return "\u25CF";
      default:
        return "\u25CB";
    }
  }
  /**
   * 获取状态文本
   * Get status text
   */
  getStatusText(status) {
    switch (status) {
      case "outline":
        return "\u5927\u7EB2";
      case "draft":
        return "\u8349\u7A3F";
      case "revised":
        return "\u4FEE\u6539";
      case "complete":
        return "\u5B8C\u6210";
      default:
        return "\u672A\u77E5";
    }
  }
  /**
   * 切换卷的展开状态
   * Toggle volume expansion
   */
  toggleVolumeExpansion(volume) {
    volume.isExpanded = !volume.isExpanded;
    this.renderOutline();
  }
  /**
   * 切换章节的展开状态
   * Toggle chapter expansion
   */
  toggleChapterExpansion(chapter) {
    chapter.isExpanded = !chapter.isExpanded;
    this.renderOutline();
  }
  /**
   * 打开场景文件
   * Open scene file
   */
  async openSceneFile(scene) {
    const file = this.app.vault.getAbstractFileByPath(scene.path);
    if (file) {
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
    }
  }
  /**
   * 添加拖拽事件
   * Add drag events
   */
  addDragEvents(element, scene) {
    element.addEventListener("dragstart", (e) => {
      this.isDragging = true;
      this.draggedElement = element;
      this.draggedSceneData = scene.data;
      element.classList.add("dragging");
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", scene.data.path);
      }
    });
    element.addEventListener("dragend", () => {
      this.isDragging = false;
      this.draggedElement = null;
      this.draggedSceneData = null;
      element.classList.remove("dragging");
      this.containerEl.querySelectorAll(".drag-over").forEach((el) => {
        el.classList.remove("drag-over");
      });
      this.hideDropIndicator();
    });
    element.addEventListener("dragover", (e) => {
      if (this.isDragging && this.draggedElement !== element) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        this.containerEl.querySelectorAll(".drag-over").forEach((el) => {
          el.classList.remove("drag-over");
        });
        element.classList.add("drag-over");
        this.showDropIndicator(element, e);
      }
    });
    element.addEventListener("dragleave", (e) => {
      const rect = element.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;
      if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
        element.classList.remove("drag-over");
        this.hideDropIndicator();
      }
    });
    element.addEventListener("drop", (e) => {
      e.preventDefault();
      element.classList.remove("drag-over");
      if (this.isDragging && this.draggedSceneData && this.draggedElement !== element) {
        const targetScenePath = element.getAttribute("data-scene-path");
        if (targetScenePath) {
          this.handleSceneDrop(this.draggedSceneData, targetScenePath);
        }
      }
    });
  }
  /**
   * 处理场景拖拽放置
   * Handle scene drop
   */
  async handleSceneDrop(draggedScene, targetScenePath) {
    try {
      const targetScene = this.projectService.getSceneData(targetScenePath);
      if (!targetScene) {
        console.error("Target scene not found:", targetScenePath);
        return;
      }
      if (draggedScene.path === targetScene.path) {
        return;
      }
      console.log(`Moving scene ${draggedScene.title} to position of ${targetScene.title}`);
      await this.reorderScenes(draggedScene, targetScene);
      this.renderOutline();
    } catch (error) {
      console.error("Failed to handle scene drop:", error);
      this.showErrorMessage("\u573A\u666F\u79FB\u52A8\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 重排序场景
   * Reorder scenes
   */
  async reorderScenes(draggedScene, targetScene) {
    const isCrossChapter = draggedScene.chapterIndex !== targetScene.chapterIndex;
    if (isCrossChapter) {
      await this.moveSceneToChapter(draggedScene, targetScene);
    } else {
      await this.reorderScenesInChapter(draggedScene, targetScene);
    }
  }
  /**
   * 将场景移动到不同章节
   * Move scene to different chapter
   */
  async moveSceneToChapter(draggedScene, targetScene) {
    const targetChapterScenes = this.projectService.getAllScenes().filter((scene) => scene.chapterIndex === targetScene.chapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    const targetIndex = targetScene.sceneIndex;
    for (const scene of targetChapterScenes) {
      if (scene.sceneIndex >= targetIndex) {
        const newSceneIndex = scene.sceneIndex + 1;
        await this.updateSceneIndex(scene, newSceneIndex);
      }
    }
    await this.updateSceneChapterAndIndex(draggedScene, targetScene.chapterIndex, targetIndex);
    await this.reindexChapterScenes(draggedScene.chapterIndex);
  }
  /**
   * 在同一章节内重排序场景
   * Reorder scenes within the same chapter
   */
  async reorderScenesInChapter(draggedScene, targetScene) {
    const chapterScenes = this.projectService.getAllScenes().filter((scene) => scene.chapterIndex === draggedScene.chapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    const draggedIndex = draggedScene.sceneIndex;
    const targetIndex = targetScene.sceneIndex;
    const newTargetIndex = targetIndex > draggedIndex ? targetIndex - 1 : targetIndex;
    let newIndex = 1;
    for (const scene of chapterScenes) {
      if (scene.path === draggedScene.path) {
        continue;
      }
      if (newIndex === newTargetIndex + 1) {
        await this.updateSceneIndex(draggedScene, newIndex);
        newIndex++;
      }
      if (scene.sceneIndex !== newIndex) {
        await this.updateSceneIndex(scene, newIndex);
      }
      newIndex++;
    }
    if (newTargetIndex >= chapterScenes.length - 1) {
      await this.updateSceneIndex(draggedScene, newIndex);
    }
  }
  /**
   * 更新场景的章节和索引
   * Update scene chapter and index
   */
  async updateSceneChapterAndIndex(scene, newChapterIndex, newSceneIndex) {
    await this.projectService.updateSceneMetadata(scene.path, {
      chapterIndex: newChapterIndex,
      sceneIndex: newSceneIndex
    });
    const newPath = this.generateNewScenePath(scene, newChapterIndex, newSceneIndex);
    if (newPath !== scene.path) {
      await this.moveSceneFile(scene.path, newPath);
    }
  }
  /**
   * 更新场景索引
   * Update scene index
   */
  async updateSceneIndex(scene, newSceneIndex) {
    if (scene.sceneIndex === newSceneIndex) {
      return;
    }
    await this.projectService.updateSceneMetadata(scene.path, {
      sceneIndex: newSceneIndex
    });
    const newPath = this.generateNewScenePath(scene, scene.chapterIndex, newSceneIndex);
    if (newPath !== scene.path) {
      await this.moveSceneFile(scene.path, newPath);
    }
  }
  /**
   * 重新整理章节场景索引
   * Reindex chapter scenes
   */
  async reindexChapterScenes(chapterIndex) {
    const chapterScenes = this.projectService.getAllScenes().filter((scene) => scene.chapterIndex === chapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    let newIndex = 1;
    for (const scene of chapterScenes) {
      if (scene.sceneIndex !== newIndex) {
        await this.updateSceneIndex(scene, newIndex);
      }
      newIndex++;
    }
  }
  /**
   * 生成新的场景文件路径
   * Generate new scene file path
   */
  generateNewScenePath(scene, chapterIndex, sceneIndex) {
    const pathParts = scene.path.split("/");
    const fileName = pathParts[pathParts.length - 1];
    const titleMatch = fileName.match(/^\d+-\d+\s+(.+)\.md$/);
    const title = titleMatch ? titleMatch[1] : scene.title;
    const newFileName = `${chapterIndex.toString().padStart(2, "0")}-${sceneIndex.toString().padStart(2, "0")} ${title}.md`;
    const newPathParts = [...pathParts];
    newPathParts[newPathParts.length - 1] = newFileName;
    return newPathParts.join("/");
  }
  /**
   * 移动场景文件
   * Move scene file
   */
  async moveSceneFile(oldPath, newPath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(oldPath);
      if (file) {
        await this.app.vault.rename(file, newPath);
        console.log(`Moved scene file from ${oldPath} to ${newPath}`);
      }
    } catch (error) {
      console.error(`Failed to move scene file from ${oldPath} to ${newPath}:`, error);
      throw error;
    }
  }
  /**
   * 显示拖拽插入指示器
   * Show drop indicator
   */
  showDropIndicator(element, event) {
    this.hideDropIndicator();
    const rect = element.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    const insertBefore = event.clientY < midY;
    const indicator = document.createElement("div");
    indicator.className = "outline-drop-indicator";
    indicator.style.cssText = `
      position: absolute;
      left: ${rect.left}px;
      width: ${rect.width}px;
      height: 2px;
      background: var(--interactive-accent);
      z-index: 1000;
      pointer-events: none;
    `;
    if (insertBefore) {
      indicator.style.top = `${rect.top - 1}px`;
    } else {
      indicator.style.top = `${rect.bottom - 1}px`;
    }
    document.body.appendChild(indicator);
  }
  /**
   * 隐藏拖拽插入指示器
   * Hide drop indicator
   */
  hideDropIndicator() {
    const existing = document.querySelector(".outline-drop-indicator");
    if (existing) {
      existing.remove();
    }
  }
  /**
   * 显示错误消息
   * Show error message
   */
  showErrorMessage(message) {
    const errorEl = this.containerEl.createDiv("outline-error-message");
    errorEl.textContent = message;
    errorEl.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--background-modifier-error);
      color: var(--text-on-accent);
      padding: 8px 12px;
      border-radius: 4px;
      z-index: 1000;
      font-size: 0.9em;
    `;
    setTimeout(() => {
      if (errorEl.parentNode) {
        errorEl.parentNode.removeChild(errorEl);
      }
    }, 3e3);
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  cleanup() {
    this.isDragging = false;
    this.draggedElement = null;
    this.draggedSceneData = null;
    this.outlineData = [];
  }
};
var OutlineView = _OutlineView;
/** 视图类型标识符 */
OutlineView.VIEW_TYPE = "story-weaver-outline";

// src/views/TimelineView.ts
var import_obsidian7 = require("obsidian");
var _TimelineView = class extends import_obsidian7.ItemView {
  constructor(leaf, projectService) {
    super(leaf);
    /** 时间线数据 */
    this.timelineData = [];
    /** 当前筛选的角色 */
    this.filteredCharacter = null;
    /** 时间线容器 */
    this.timelineContainer = null;
    /** SVG 元素 */
    this.svg = null;
    /** 时间线配置 */
    this.config = {
      width: 800,
      height: 400,
      margin: { top: 40, right: 40, bottom: 60, left: 60 },
      eventHeight: 20,
      eventSpacing: 30,
      minZoom: 0.1,
      maxZoom: 10
    };
    /** 当前缩放级别 */
    this.currentZoom = 1;
    /** 当前滚动位置 */
    this.currentScroll = 0;
    this.projectService = projectService;
  }
  /**
   * 获取视图类型
   * Get view type
   */
  getViewType() {
    return _TimelineView.VIEW_TYPE;
  }
  /**
   * 获取视图显示名称
   * Get view display text
   */
  getDisplayText() {
    return "\u7EC7\u6587\u8005\u65F6\u95F4\u7EBF";
  }
  /**
   * 获取视图图标
   * Get view icon
   */
  getIcon() {
    return "clock";
  }
  /**
   * 视图打开时调用
   * Called when view is opened
   */
  async onOpen() {
    console.log("TimelineView opened");
    if (!this.projectService.currentProject) {
      console.log("No project loaded, attempting auto-load...");
      await this.projectService.autoLoadProject();
    }
    this.renderTimeline();
  }
  /**
   * 视图关闭时调用
   * Called when view is closed
   */
  async onClose() {
    console.log("TimelineView closed");
    this.cleanup();
  }
  /**
   * 刷新时间线视图
   * Refresh timeline view
   */
  refresh() {
    this.renderTimeline();
  }
  /**
   * 处理项目变更
   * Handle project change
   */
  onProjectChanged() {
    this.timelineData = [];
    this.filteredCharacter = null;
    this.renderTimeline();
  }
  /**
   * 渲染时间线视图
   * Render timeline view
   */
  renderTimeline() {
    const container = this.containerEl;
    container.empty();
    if (!this.projectService.currentProject) {
      this.renderNoProjectMessage(container);
      return;
    }
    if (!this.projectService.isCacheInitialized()) {
      this.renderLoadingMessage(container);
      return;
    }
    this.buildTimelineData();
    if (this.timelineData.length === 0) {
      this.renderNoTimelineDataMessage(container);
      return;
    }
    this.renderTimelineInterface(container);
  }
  /**
   * 渲染无项目消息
   * Render no project message
   */
  renderNoProjectMessage(container) {
    const messageEl = container.createDiv("timeline-no-project");
    messageEl.createEl("h3", { text: "\u672A\u52A0\u8F7D\u9879\u76EE" });
    messageEl.createEl("p", { text: "\u8BF7\u5148\u521B\u5EFA\u6216\u52A0\u8F7D\u4E00\u4E2A\u5199\u4F5C\u9879\u76EE" });
    const createButton = messageEl.createEl("button", {
      text: "\u521B\u5EFA\u65B0\u9879\u76EE",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      this.app.commands.executeCommandById("story-weaver:create-new-project");
    });
  }
  /**
   * 渲染加载消息
   * Render loading message
   */
  renderLoadingMessage(container) {
    const messageEl = container.createDiv("timeline-loading");
    messageEl.createEl("div", { text: "\u6B63\u5728\u52A0\u8F7D\u9879\u76EE\u6570\u636E...", cls: "loading-text" });
    const spinner = messageEl.createDiv("loading-spinner");
    spinner.innerHTML = "\u27F3";
  }
  /**
   * 渲染无时间线数据消息
   * Render no timeline data message
   */
  renderNoTimelineDataMessage(container) {
    const messageEl = container.createDiv("timeline-no-data");
    messageEl.createEl("h3", { text: "\u6682\u65E0\u65F6\u95F4\u7EBF\u6570\u636E" });
    messageEl.createEl("p", { text: "\u8BF7\u5728\u573A\u666F\u7684 YAML \u5143\u6570\u636E\u4E2D\u6DFB\u52A0 story_time \u5B57\u6BB5" });
    messageEl.createEl("p", { text: '\u683C\u5F0F\u793A\u4F8B: story_time: "2025-08-15 22:30"' });
    const exampleEl = messageEl.createDiv("timeline-example");
    exampleEl.createEl("h4", { text: "\u793A\u4F8B YAML:" });
    const codeEl = exampleEl.createEl("pre");
    codeEl.createEl("code", { text: `---
tags: [scene]
status: 'draft'
pov: '[[\u4E3B\u89D2]]'
location: '[[\u57CE\u5E02\u5E7F\u573A]]'
story_time: '2025-08-15 14:30'
synopsis: '\u4E3B\u89D2\u5728\u5E7F\u573A\u9047\u5230\u4E86\u91CD\u8981\u4EBA\u7269'
---` });
  }
  /**
   * 构建时间线数据
   * Build timeline data
   */
  buildTimelineData() {
    const scenes = this.projectService.getAllScenes();
    const scenesWithTime = scenes.filter((scene) => scene.storyTime !== null);
    scenesWithTime.sort((a, b) => {
      if (!a.storyTime || !b.storyTime)
        return 0;
      return a.storyTime.getTime() - b.storyTime.getTime();
    });
    this.timelineData = scenesWithTime.map((scene) => ({
      id: scene.path,
      title: scene.title,
      time: scene.storyTime,
      scene,
      pov: scene.pov,
      location: scene.location,
      synopsis: scene.synopsis
    }));
    console.log(`Built timeline with ${this.timelineData.length} events`);
  }
  /**
   * 渲染时间线界面
   * Render timeline interface
   */
  renderTimelineInterface(container) {
    const timelineContainer = container.createDiv("timeline-container");
    this.renderToolbar(timelineContainer);
    this.renderTimelineBody(timelineContainer);
    this.timelineContainer = timelineContainer;
  }
  /**
   * 渲染工具栏
   * Render toolbar
   */
  renderToolbar(container) {
    const toolbar = container.createDiv("timeline-toolbar");
    const titleSection = toolbar.createDiv("timeline-title-section");
    titleSection.createEl("h3", { text: "\u6545\u4E8B\u65F6\u95F4\u7EBF" });
    const statsEl = titleSection.createDiv("timeline-stats");
    statsEl.createEl("span", { text: `${this.timelineData.length} \u4E2A\u4E8B\u4EF6` });
    const controlsSection = toolbar.createDiv("timeline-controls");
    const zoomControls = controlsSection.createDiv("timeline-zoom-controls");
    zoomControls.createEl("span", { text: "\u7F29\u653E:" });
    const zoomOutBtn = zoomControls.createEl("button", { text: "\u2212", cls: "timeline-zoom-btn" });
    zoomOutBtn.addEventListener("click", () => this.zoomOut());
    const zoomLevel = zoomControls.createEl("span", { text: "100%", cls: "timeline-zoom-level" });
    const zoomInBtn = zoomControls.createEl("button", { text: "+", cls: "timeline-zoom-btn" });
    zoomInBtn.addEventListener("click", () => this.zoomIn());
    const resetZoomBtn = zoomControls.createEl("button", { text: "\u91CD\u7F6E", cls: "timeline-reset-btn" });
    resetZoomBtn.addEventListener("click", () => this.resetZoom());
    const filterSection = controlsSection.createDiv("timeline-filter-section");
    filterSection.createEl("span", { text: "\u7B5B\u9009\u89D2\u8272:" });
    const characterSelect = filterSection.createEl("select", { cls: "timeline-character-filter" });
    this.populateCharacterFilter(characterSelect);
    characterSelect.addEventListener("change", (e) => {
      const target = e.target;
      this.filterByCharacter(target.value || null);
    });
  }
  /**
   * 填充角色筛选器
   * Populate character filter
   */
  populateCharacterFilter(select) {
    const allOption = select.createEl("option", { value: "", text: "\u5168\u90E8\u89D2\u8272" });
    const characters = /* @__PURE__ */ new Set();
    this.timelineData.forEach((event) => {
      if (event.pov) {
        characters.add(event.pov);
      }
    });
    Array.from(characters).sort().forEach((character) => {
      const characterName = character.replace(/\[\[|\]\]/g, "");
      select.createEl("option", { value: character, text: characterName });
    });
  }
  /**
   * 渲染时间线主体
   * Render timeline body
   */
  renderTimelineBody(container) {
    const bodyContainer = container.createDiv("timeline-body");
    const svgContainer = bodyContainer.createDiv("timeline-svg-container");
    svgContainer.style.cssText = `
      width: 100%;
      height: ${this.config.height}px;
      overflow: auto;
      border: 1px solid var(--background-modifier-border);
      background: var(--background-primary);
    `;
    this.svg = this.createSVGElement("svg", {
      width: this.config.width.toString(),
      height: this.config.height.toString(),
      viewBox: `0 0 ${this.config.width} ${this.config.height}`
    });
    svgContainer.appendChild(this.svg);
    this.renderTimelineContent();
    this.addInteractionEvents(svgContainer);
  }
  /**
   * 渲染时间线内容
   * Render timeline content
   */
  renderTimelineContent() {
    if (!this.svg)
      return;
    this.svg.innerHTML = "";
    const filteredData = this.filteredCharacter ? this.timelineData.filter((event) => event.pov === this.filteredCharacter) : this.timelineData;
    if (filteredData.length === 0) {
      this.renderNoFilteredDataMessage();
      return;
    }
    const timeRange = this.calculateTimeRange(filteredData);
    this.renderTimeAxis(timeRange);
    this.renderTimelineEvents(filteredData, timeRange);
  }
  /**
   * 渲染无筛选数据消息
   * Render no filtered data message
   */
  renderNoFilteredDataMessage() {
    if (!this.svg)
      return;
    const text = this.createSVGElement("text", {
      x: (this.config.width / 2).toString(),
      y: (this.config.height / 2).toString(),
      "text-anchor": "middle",
      "dominant-baseline": "middle",
      fill: "var(--text-muted)",
      "font-size": "14"
    });
    text.textContent = "\u8BE5\u89D2\u8272\u6CA1\u6709\u76F8\u5173\u7684\u65F6\u95F4\u7EBF\u4E8B\u4EF6";
    this.svg.appendChild(text);
  }
  /**
   * 计算时间范围
   * Calculate time range
   */
  calculateTimeRange(data) {
    if (data.length === 0) {
      const now = new Date();
      return { start: now, end: now, duration: 0 };
    }
    const times = data.map((event) => event.time.getTime());
    const start = new Date(Math.min(...times));
    const end = new Date(Math.max(...times));
    const duration = end.getTime() - start.getTime();
    if (duration === 0) {
      const buffer = 24 * 60 * 60 * 1e3;
      return {
        start: new Date(start.getTime() - buffer),
        end: new Date(end.getTime() + buffer),
        duration: buffer * 2
      };
    }
    return { start, end, duration };
  }
  /**
   * 渲染时间轴
   * Render time axis
   */
  renderTimeAxis(timeRange) {
    if (!this.svg)
      return;
    const axisY = this.config.height - this.config.margin.bottom;
    const axisStartX = this.config.margin.left;
    const axisEndX = this.config.width - this.config.margin.right;
    const axisWidth = axisEndX - axisStartX;
    const axisLine = this.createSVGElement("line", {
      x1: axisStartX.toString(),
      y1: axisY.toString(),
      x2: axisEndX.toString(),
      y2: axisY.toString(),
      stroke: "var(--text-normal)",
      "stroke-width": "2"
    });
    this.svg.appendChild(axisLine);
    const tickCount = Math.min(10, Math.max(3, Math.floor(axisWidth / 100)));
    for (let i = 0; i <= tickCount; i++) {
      const ratio = i / tickCount;
      const tickX = axisStartX + axisWidth * ratio;
      const tickTime = new Date(timeRange.start.getTime() + timeRange.duration * ratio);
      const tickLine = this.createSVGElement("line", {
        x1: tickX.toString(),
        y1: axisY.toString(),
        x2: tickX.toString(),
        y2: (axisY + 5).toString(),
        stroke: "var(--text-normal)",
        "stroke-width": "1"
      });
      this.svg.appendChild(tickLine);
      const tickLabel = this.createSVGElement("text", {
        x: tickX.toString(),
        y: (axisY + 20).toString(),
        "text-anchor": "middle",
        fill: "var(--text-muted)",
        "font-size": "12"
      });
      tickLabel.textContent = this.formatTimeLabel(tickTime);
      this.svg.appendChild(tickLabel);
    }
  }
  /**
   * 渲染时间线事件
   * Render timeline events
   */
  renderTimelineEvents(data, timeRange) {
    if (!this.svg)
      return;
    const axisY = this.config.height - this.config.margin.bottom;
    const axisStartX = this.config.margin.left;
    const axisWidth = this.config.width - this.config.margin.right - axisStartX;
    data.forEach((event, index) => {
      const timeRatio = timeRange.duration > 0 ? (event.time.getTime() - timeRange.start.getTime()) / timeRange.duration : 0.5;
      const eventX = axisStartX + axisWidth * timeRatio;
      const eventY = axisY - 40 - index % 3 * this.config.eventSpacing;
      const connectionLine = this.createSVGElement("line", {
        x1: eventX.toString(),
        y1: axisY.toString(),
        x2: eventX.toString(),
        y2: eventY.toString(),
        stroke: "var(--text-accent)",
        "stroke-width": "1",
        "stroke-dasharray": "2,2"
      });
      this.svg.appendChild(connectionLine);
      const eventCircle = this.createSVGElement("circle", {
        cx: eventX.toString(),
        cy: eventY.toString(),
        r: "6",
        fill: this.getEventColor(event.scene.status),
        stroke: "var(--background-primary)",
        "stroke-width": "2",
        cursor: "pointer"
      });
      eventCircle.addEventListener("click", () => {
        this.jumpToScene(event.scene);
      });
      eventCircle.addEventListener("mouseenter", () => {
        this.showEventTooltip(event, eventX, eventY);
      });
      eventCircle.addEventListener("mouseleave", () => {
        this.hideEventTooltip();
      });
      this.svg.appendChild(eventCircle);
      const eventLabel = this.createSVGElement("text", {
        x: eventX.toString(),
        y: (eventY - 15).toString(),
        "text-anchor": "middle",
        fill: "var(--text-normal)",
        "font-size": "11",
        "font-weight": "bold",
        cursor: "pointer"
      });
      eventLabel.textContent = this.truncateText(event.title, 15);
      eventLabel.addEventListener("click", () => {
        this.jumpToScene(event.scene);
      });
      this.svg.appendChild(eventLabel);
    });
  }
  /**
   * 获取事件颜色
   * Get event color based on scene status
   */
  getEventColor(status) {
    switch (status) {
      case "outline":
        return "var(--text-muted)";
      case "draft":
        return "var(--color-yellow)";
      case "revised":
        return "var(--color-orange)";
      case "complete":
        return "var(--color-green)";
      default:
        return "var(--text-accent)";
    }
  }
  /**
   * 格式化时间标签
   * Format time label
   */
  formatTimeLabel(time) {
    const now = new Date();
    const diffDays = Math.abs(time.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24);
    if (diffDays < 1) {
      return time.toLocaleTimeString("zh-CN", { hour: "2-digit", minute: "2-digit" });
    } else if (diffDays < 365) {
      return time.toLocaleDateString("zh-CN", { month: "short", day: "numeric" });
    } else {
      return time.toLocaleDateString("zh-CN", { year: "numeric", month: "short" });
    }
  }
  /**
   * 截断文本
   * Truncate text
   */
  truncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    return text.substring(0, maxLength - 1) + "\u2026";
  }
  /**
   * 显示事件提示框
   * Show event tooltip
   */
  showEventTooltip(event, x, y) {
    this.hideEventTooltip();
    const tooltip = document.createElement("div");
    tooltip.className = "timeline-tooltip";
    tooltip.style.cssText = `
      position: absolute;
      left: ${x + 10}px;
      top: ${y - 10}px;
      background: var(--background-primary);
      border: 1px solid var(--background-modifier-border);
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 12px;
      z-index: 1000;
      max-width: 200px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    `;
    const title = tooltip.createEl("div", { text: event.title, cls: "tooltip-title" });
    title.style.fontWeight = "bold";
    title.style.marginBottom = "4px";
    const time = tooltip.createEl("div", { text: event.time.toLocaleString("zh-CN"), cls: "tooltip-time" });
    time.style.color = "var(--text-muted)";
    time.style.fontSize = "11px";
    time.style.marginBottom = "4px";
    if (event.pov) {
      const pov = tooltip.createEl("div", { text: `\u89C6\u89D2: ${event.pov.replace(/\[\[|\]\]/g, "")}`, cls: "tooltip-pov" });
      pov.style.fontSize = "11px";
      pov.style.marginBottom = "2px";
    }
    if (event.location) {
      const location = tooltip.createEl("div", { text: `\u5730\u70B9: ${event.location.replace(/\[\[|\]\]/g, "")}`, cls: "tooltip-location" });
      location.style.fontSize = "11px";
      location.style.marginBottom = "2px";
    }
    if (event.synopsis) {
      const synopsis = tooltip.createEl("div", { text: event.synopsis, cls: "tooltip-synopsis" });
      synopsis.style.fontSize = "11px";
      synopsis.style.marginTop = "4px";
      synopsis.style.fontStyle = "italic";
    }
    document.body.appendChild(tooltip);
  }
  /**
   * 隐藏事件提示框
   * Hide event tooltip
   */
  hideEventTooltip() {
    const existing = document.querySelector(".timeline-tooltip");
    if (existing) {
      existing.remove();
    }
  }
  /**
   * 跳转到场景
   * Jump to scene
   */
  async jumpToScene(scene) {
    const file = this.app.vault.getAbstractFileByPath(scene.path);
    if (file) {
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
      console.log(`Jumped to scene: ${scene.title}`);
    }
  }
  /**
   * 按角色筛选
   * Filter by character
   */
  filterByCharacter(characterId) {
    this.filteredCharacter = characterId;
    this.renderTimelineContent();
    console.log(`Filtered timeline by character: ${characterId || "all"}`);
  }
  /**
   * 放大
   * Zoom in
   */
  zoomIn() {
    this.currentZoom = Math.min(this.config.maxZoom, this.currentZoom * 1.2);
    this.applyZoom();
  }
  /**
   * 缩小
   * Zoom out
   */
  zoomOut() {
    this.currentZoom = Math.max(this.config.minZoom, this.currentZoom / 1.2);
    this.applyZoom();
  }
  /**
   * 重置缩放
   * Reset zoom
   */
  resetZoom() {
    this.currentZoom = 1;
    this.currentScroll = 0;
    this.applyZoom();
  }
  /**
   * 应用缩放
   * Apply zoom
   */
  applyZoom() {
    if (!this.svg)
      return;
    const newWidth = this.config.width * this.currentZoom;
    this.svg.setAttribute("width", newWidth.toString());
    const zoomLevelEl = this.containerEl.querySelector(".timeline-zoom-level");
    if (zoomLevelEl) {
      zoomLevelEl.textContent = `${Math.round(this.currentZoom * 100)}%`;
    }
    this.config.width = newWidth;
    this.renderTimelineContent();
  }
  /**
   * 添加交互事件
   * Add interaction events
   */
  addInteractionEvents(container) {
    container.addEventListener("wheel", (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        if (e.deltaY < 0) {
          this.zoomIn();
        } else {
          this.zoomOut();
        }
      }
    });
    container.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case "=":
          case "+":
            e.preventDefault();
            this.zoomIn();
            break;
          case "-":
            e.preventDefault();
            this.zoomOut();
            break;
          case "0":
            e.preventDefault();
            this.resetZoom();
            break;
        }
      }
    });
    container.setAttribute("tabindex", "0");
  }
  /**
   * 创建 SVG 元素
   * Create SVG element
   */
  createSVGElement(tagName, attributes) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
    for (const [key, value] of Object.entries(attributes)) {
      element.setAttribute(key, value);
    }
    return element;
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  cleanup() {
    this.timelineData = [];
    this.filteredCharacter = null;
    this.timelineContainer = null;
    this.svg = null;
    this.currentZoom = 1;
    this.currentScroll = 0;
    this.hideEventTooltip();
  }
};
var TimelineView = _TimelineView;
/** 视图类型标识符 */
TimelineView.VIEW_TYPE = "story-weaver-timeline";

// src/views/CorkboardView.ts
var import_obsidian8 = require("obsidian");
var _CorkboardView = class extends import_obsidian8.ItemView {
  constructor(leaf, projectService) {
    super(leaf);
    /** 当前看板数据 */
    this.boardData = [];
    /** 拖拽状态 */
    this.isDragging = false;
    this.draggedCard = null;
    this.draggedSceneData = null;
    this.projectService = projectService;
  }
  /**
   * 获取视图类型
   * Get view type
   */
  getViewType() {
    return _CorkboardView.VIEW_TYPE;
  }
  /**
   * 获取视图显示名称
   * Get view display text
   */
  getDisplayText() {
    return "\u7EC7\u6587\u8005\u770B\u677F";
  }
  /**
   * 获取视图图标
   * Get view icon
   */
  getIcon() {
    return "layout-dashboard";
  }
  /**
   * 视图打开时调用
   * Called when view is opened
   */
  async onOpen() {
    console.log("CorkboardView opened");
    if (!this.projectService.currentProject) {
      console.log("No project loaded, attempting auto-load...");
      await this.projectService.autoLoadProject();
    }
    this.renderBoard();
  }
  /**
   * 视图关闭时调用
   * Called when view is closed
   */
  async onClose() {
    console.log("CorkboardView closed");
    this.cleanup();
  }
  /**
   * 刷新看板视图
   * Refresh corkboard view
   */
  refresh() {
    this.renderBoard();
  }
  /**
   * 处理项目变更
   * Handle project change
   */
  onProjectChanged() {
    this.boardData = [];
    this.renderBoard();
  }
  /**
   * 渲染看板视图
   * Render corkboard view
   */
  renderBoard() {
    const container = this.containerEl;
    container.empty();
    if (!this.projectService.currentProject) {
      this.renderNoProjectMessage(container);
      return;
    }
    if (!this.projectService.isCacheInitialized()) {
      this.renderLoadingMessage(container);
      return;
    }
    this.buildBoardData();
    this.renderBoardLayout(container);
  }
  /**
   * 渲染无项目消息
   * Render no project message
   */
  renderNoProjectMessage(container) {
    const messageEl = container.createDiv("corkboard-no-project");
    messageEl.createEl("h3", { text: "\u672A\u52A0\u8F7D\u9879\u76EE" });
    messageEl.createEl("p", { text: "\u8BF7\u5148\u521B\u5EFA\u6216\u52A0\u8F7D\u4E00\u4E2A\u5199\u4F5C\u9879\u76EE" });
    const createButton = messageEl.createEl("button", {
      text: "\u521B\u5EFA\u65B0\u9879\u76EE",
      cls: "mod-cta"
    });
    createButton.addEventListener("click", () => {
      this.app.commands.executeCommandById("story-weaver:create-new-project");
    });
  }
  /**
   * 渲染加载消息
   * Render loading message
   */
  renderLoadingMessage(container) {
    const messageEl = container.createDiv("corkboard-loading");
    messageEl.createEl("div", { text: "\u6B63\u5728\u52A0\u8F7D\u9879\u76EE\u6570\u636E...", cls: "loading-text" });
    const spinner = messageEl.createDiv("loading-spinner");
    spinner.innerHTML = "\u27F3";
  }
  /**
   * 构建看板数据结构
   * Build corkboard data structure
   */
  buildBoardData() {
    const scenes = this.projectService.getAllScenes();
    scenes.sort((a, b) => {
      if (a.chapterIndex !== b.chapterIndex) {
        return a.chapterIndex - b.chapterIndex;
      }
      return a.sceneIndex - b.sceneIndex;
    });
    const chapterMap = /* @__PURE__ */ new Map();
    for (const scene of scenes) {
      if (!chapterMap.has(scene.chapterIndex)) {
        const pathParts = scene.path.split("/");
        let chapterName = `\u7B2C${scene.chapterIndex}\u7AE0`;
        if (pathParts.length >= 4) {
          const chapterPart = pathParts[3];
          if (chapterPart.includes("\u7AE0")) {
            chapterName = chapterPart;
          }
        }
        chapterMap.set(scene.chapterIndex, {
          index: scene.chapterIndex,
          title: chapterName,
          scenes: []
        });
      }
      const chapter = chapterMap.get(scene.chapterIndex);
      chapter.scenes.push(scene);
    }
    this.boardData = Array.from(chapterMap.values()).sort((a, b) => a.index - b.index);
  }
  /**
   * 渲染看板布局
   * Render board layout
   */
  renderBoardLayout(container) {
    const boardContainer = container.createDiv("corkboard-container");
    const headerEl = boardContainer.createDiv("corkboard-header");
    headerEl.createEl("h3", { text: "\u9879\u76EE\u770B\u677F" });
    const statsEl = headerEl.createDiv("corkboard-stats");
    const totalScenes = this.projectService.getAllScenes().length;
    statsEl.createEl("span", { text: `${this.boardData.length}\u7AE0 ${totalScenes}\u573A\u666F` });
    const boardMain = boardContainer.createDiv("corkboard-main");
    for (const chapter of this.boardData) {
      this.renderChapterColumn(boardMain, chapter);
    }
    if (this.boardData.length === 0) {
      const emptyEl = boardMain.createDiv("corkboard-empty");
      emptyEl.createEl("p", { text: "\u6682\u65E0\u7A3F\u4EF6\u5185\u5BB9" });
      emptyEl.createEl("p", { text: '\u8BF7\u5728 "10_\u7A3F\u4EF6" \u6587\u4EF6\u5939\u4E2D\u521B\u5EFA\u7AE0\u8282\u548C\u573A\u666F' });
    }
  }
  /**
   * 渲染章节列
   * Render chapter column
   */
  renderChapterColumn(container, chapter) {
    const columnEl = container.createDiv("corkboard-column");
    columnEl.setAttribute("data-chapter-index", chapter.index.toString());
    const columnHeader = columnEl.createDiv("corkboard-column-header");
    const titleEl = columnHeader.createEl("h4", { text: chapter.title });
    const statsEl = columnHeader.createDiv("corkboard-column-stats");
    const wordCount = chapter.scenes.reduce((sum, scene) => sum + scene.wordCount, 0);
    statsEl.textContent = `${chapter.scenes.length}\u573A\u666F ${wordCount}\u5B57`;
    const cardsContainer = columnEl.createDiv("corkboard-cards");
    this.addColumnDropEvents(cardsContainer, chapter);
    for (const scene of chapter.scenes) {
      this.createSceneCard(cardsContainer, scene);
    }
    if (chapter.scenes.length === 0) {
      const emptyCard = cardsContainer.createDiv("corkboard-empty-card");
      emptyCard.textContent = "\u6682\u65E0\u573A\u666F";
    }
  }
  /**
   * 创建场景卡片
   * Create scene card
   */
  createSceneCard(container, scene) {
    const cardEl = container.createDiv("corkboard-card");
    cardEl.setAttribute("data-scene-path", scene.path);
    cardEl.setAttribute("data-status", scene.status);
    cardEl.setAttribute("draggable", "true");
    const statusIndicator = cardEl.createDiv("corkboard-card-status");
    statusIndicator.classList.add(`status-${scene.status}`);
    const titleEl = cardEl.createDiv("corkboard-card-title");
    titleEl.textContent = scene.title;
    if (scene.synopsis) {
      const synopsisEl = cardEl.createDiv("corkboard-card-synopsis");
      synopsisEl.textContent = scene.synopsis;
    }
    const infoEl = cardEl.createDiv("corkboard-card-info");
    if (scene.wordCount > 0) {
      const wordCountEl = infoEl.createSpan("corkboard-card-wordcount");
      wordCountEl.textContent = `${scene.wordCount}\u5B57`;
    }
    if (scene.pov) {
      const povEl = infoEl.createSpan("corkboard-card-pov");
      const povName = this.extractLinkText(scene.pov);
      povEl.textContent = `\u89C6\u89D2: ${povName}`;
    }
    if (scene.location) {
      const locationEl = infoEl.createSpan("corkboard-card-location");
      const locationName = this.extractLinkText(scene.location);
      locationEl.textContent = `\u5730\u70B9: ${locationName}`;
    }
    cardEl.addEventListener("click", () => {
      this.openSceneFile(scene);
    });
    this.addCardDragEvents(cardEl, scene);
    return cardEl;
  }
  /**
   * 提取链接文本
   * Extract link text from wiki link format
   */
  extractLinkText(linkText) {
    const match = linkText.match(/\[\[([^\]]+)\]\]/);
    if (match) {
      return match[1];
    }
    return linkText;
  }
  /**
   * 打开场景文件
   * Open scene file
   */
  async openSceneFile(scene) {
    const file = this.app.vault.getAbstractFileByPath(scene.path);
    if (file) {
      const leaf = this.app.workspace.getUnpinnedLeaf();
      await leaf.openFile(file);
    }
  }
  /**
   * 添加卡片拖拽事件
   * Add card drag events
   */
  addCardDragEvents(cardEl, scene) {
    cardEl.addEventListener("dragstart", (e) => {
      this.isDragging = true;
      this.draggedCard = cardEl;
      this.draggedSceneData = scene;
      cardEl.classList.add("dragging");
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", scene.path);
      }
    });
    cardEl.addEventListener("dragend", () => {
      this.isDragging = false;
      this.draggedCard = null;
      this.draggedSceneData = null;
      cardEl.classList.remove("dragging");
      this.containerEl.querySelectorAll(".drag-over").forEach((el) => {
        el.classList.remove("drag-over");
      });
      this.hideDropIndicator();
    });
  }
  /**
   * 添加列拖拽放置事件
   * Add column drop events
   */
  addColumnDropEvents(cardsContainer, chapter) {
    cardsContainer.addEventListener("dragover", (e) => {
      if (this.isDragging && this.draggedSceneData) {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        this.containerEl.querySelectorAll(".drag-over").forEach((el) => {
          el.classList.remove("drag-over");
        });
        cardsContainer.classList.add("drag-over");
        this.showDropIndicator(cardsContainer, e, chapter);
      }
    });
    cardsContainer.addEventListener("dragleave", (e) => {
      const rect = cardsContainer.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;
      if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
        cardsContainer.classList.remove("drag-over");
        this.hideDropIndicator();
      }
    });
    cardsContainer.addEventListener("drop", (e) => {
      e.preventDefault();
      cardsContainer.classList.remove("drag-over");
      if (this.isDragging && this.draggedSceneData) {
        this.handleCardDrop(this.draggedSceneData, chapter, e);
      }
    });
  }
  /**
   * 处理卡片拖拽放置
   * Handle card drop
   */
  async handleCardDrop(draggedScene, targetChapter, event) {
    try {
      const insertIndex = this.calculateInsertIndex(event, targetChapter);
      console.log(`Moving scene ${draggedScene.title} to chapter ${targetChapter.index} at position ${insertIndex}`);
      await this.moveSceneToChapter(draggedScene, targetChapter.index, insertIndex);
      this.renderBoard();
    } catch (error) {
      console.error("Failed to handle card drop:", error);
      this.showErrorMessage("\u573A\u666F\u79FB\u52A8\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 计算插入位置索引
   * Calculate insert index based on drop position
   */
  calculateInsertIndex(event, targetChapter) {
    const cardsContainer = event.currentTarget;
    const cards = Array.from(cardsContainer.querySelectorAll(".corkboard-card:not(.dragging)"));
    if (cards.length === 0) {
      return 1;
    }
    const mouseY = event.clientY;
    for (let i = 0; i < cards.length; i++) {
      const card = cards[i];
      const rect = card.getBoundingClientRect();
      const cardMidY = rect.top + rect.height / 2;
      if (mouseY < cardMidY) {
        return i + 1;
      }
    }
    return cards.length + 1;
  }
  /**
   * 将场景移动到指定章节
   * Move scene to specified chapter
   */
  async moveSceneToChapter(scene, targetChapterIndex, insertIndex) {
    if (scene.chapterIndex === targetChapterIndex) {
      await this.reorderSceneInChapter(scene, insertIndex);
    } else {
      await this.moveSceneBetweenChapters(scene, targetChapterIndex, insertIndex);
    }
  }
  /**
   * 在同一章节内重排序场景
   * Reorder scene within the same chapter
   */
  async reorderSceneInChapter(scene, newIndex) {
    const chapterScenes = this.projectService.getAllScenes().filter((s) => s.chapterIndex === scene.chapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    let currentIndex = 1;
    for (const chapterScene of chapterScenes) {
      if (chapterScene.path === scene.path) {
        continue;
      }
      if (currentIndex === newIndex) {
        await this.updateSceneIndex(scene, currentIndex);
        currentIndex++;
      }
      if (chapterScene.sceneIndex !== currentIndex) {
        await this.updateSceneIndex(chapterScene, currentIndex);
      }
      currentIndex++;
    }
    if (newIndex > chapterScenes.length) {
      await this.updateSceneIndex(scene, currentIndex);
    }
  }
  /**
   * 在不同章节间移动场景
   * Move scene between different chapters
   */
  async moveSceneBetweenChapters(scene, targetChapterIndex, insertIndex) {
    const targetChapterScenes = this.projectService.getAllScenes().filter((s) => s.chapterIndex === targetChapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    for (const targetScene of targetChapterScenes) {
      if (targetScene.sceneIndex >= insertIndex) {
        await this.updateSceneIndex(targetScene, targetScene.sceneIndex + 1);
      }
    }
    await this.updateSceneChapterAndIndex(scene, targetChapterIndex, insertIndex);
    await this.reindexChapterScenes(scene.chapterIndex);
  }
  /**
   * 更新场景的章节和索引
   * Update scene chapter and index
   */
  async updateSceneChapterAndIndex(scene, newChapterIndex, newSceneIndex) {
    await this.projectService.updateSceneMetadata(scene.path, {
      chapterIndex: newChapterIndex,
      sceneIndex: newSceneIndex
    });
    const newPath = this.generateNewScenePath(scene, newChapterIndex, newSceneIndex);
    if (newPath !== scene.path) {
      await this.moveSceneFile(scene.path, newPath);
    }
  }
  /**
   * 更新场景索引
   * Update scene index
   */
  async updateSceneIndex(scene, newSceneIndex) {
    if (scene.sceneIndex === newSceneIndex) {
      return;
    }
    await this.projectService.updateSceneMetadata(scene.path, {
      sceneIndex: newSceneIndex
    });
    const newPath = this.generateNewScenePath(scene, scene.chapterIndex, newSceneIndex);
    if (newPath !== scene.path) {
      await this.moveSceneFile(scene.path, newPath);
    }
  }
  /**
   * 重新整理章节场景索引
   * Reindex chapter scenes
   */
  async reindexChapterScenes(chapterIndex) {
    const chapterScenes = this.projectService.getAllScenes().filter((scene) => scene.chapterIndex === chapterIndex).sort((a, b) => a.sceneIndex - b.sceneIndex);
    let newIndex = 1;
    for (const scene of chapterScenes) {
      if (scene.sceneIndex !== newIndex) {
        await this.updateSceneIndex(scene, newIndex);
      }
      newIndex++;
    }
  }
  /**
   * 生成新的场景文件路径
   * Generate new scene file path
   */
  generateNewScenePath(scene, chapterIndex, sceneIndex) {
    const pathParts = scene.path.split("/");
    const fileName = pathParts[pathParts.length - 1];
    const titleMatch = fileName.match(/^\d+-\d+\s+(.+)\.md$/);
    const title = titleMatch ? titleMatch[1] : scene.title;
    const newFileName = `${chapterIndex.toString().padStart(2, "0")}-${sceneIndex.toString().padStart(2, "0")} ${title}.md`;
    const newPathParts = [...pathParts];
    newPathParts[newPathParts.length - 1] = newFileName;
    return newPathParts.join("/");
  }
  /**
   * 移动场景文件
   * Move scene file
   */
  async moveSceneFile(oldPath, newPath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(oldPath);
      if (file) {
        await this.app.vault.rename(file, newPath);
        console.log(`Moved scene file from ${oldPath} to ${newPath}`);
      }
    } catch (error) {
      console.error(`Failed to move scene file from ${oldPath} to ${newPath}:`, error);
      throw error;
    }
  }
  /**
   * 显示拖拽插入指示器
   * Show drop indicator
   */
  showDropIndicator(container, event, chapter) {
    this.hideDropIndicator();
    const cards = Array.from(container.querySelectorAll(".corkboard-card:not(.dragging)"));
    const mouseY = event.clientY;
    let insertElement = null;
    let insertBefore = true;
    if (cards.length === 0) {
      insertElement = container;
      insertBefore = true;
    } else {
      for (let i = 0; i < cards.length; i++) {
        const card = cards[i];
        const rect = card.getBoundingClientRect();
        const cardMidY = rect.top + rect.height / 2;
        if (mouseY < cardMidY) {
          insertElement = card;
          insertBefore = true;
          break;
        }
      }
      if (!insertElement) {
        insertElement = cards[cards.length - 1];
        insertBefore = false;
      }
    }
    if (insertElement) {
      const rect = insertElement.getBoundingClientRect();
      const indicator = document.createElement("div");
      indicator.className = "corkboard-drop-indicator";
      indicator.style.cssText = `
        position: absolute;
        left: ${rect.left}px;
        width: ${rect.width}px;
        height: 2px;
        background: var(--interactive-accent);
        z-index: 1000;
        pointer-events: none;
        border-radius: 1px;
      `;
      if (insertBefore) {
        indicator.style.top = `${rect.top - 1}px`;
      } else {
        indicator.style.top = `${rect.bottom - 1}px`;
      }
      document.body.appendChild(indicator);
    }
  }
  /**
   * 隐藏拖拽插入指示器
   * Hide drop indicator
   */
  hideDropIndicator() {
    const existing = document.querySelector(".corkboard-drop-indicator");
    if (existing) {
      existing.remove();
    }
  }
  /**
   * 显示错误消息
   * Show error message
   */
  showErrorMessage(message) {
    const errorEl = this.containerEl.createDiv("corkboard-error-message");
    errorEl.textContent = message;
    errorEl.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--background-modifier-error);
      color: var(--text-on-accent);
      padding: 8px 12px;
      border-radius: 4px;
      z-index: 1000;
      font-size: 0.9em;
    `;
    setTimeout(() => {
      if (errorEl.parentNode) {
        errorEl.parentNode.removeChild(errorEl);
      }
    }, 3e3);
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  cleanup() {
    this.isDragging = false;
    this.draggedCard = null;
    this.draggedSceneData = null;
    this.boardData = [];
  }
};
var CorkboardView = _CorkboardView;
/** 视图类型标识符 */
CorkboardView.VIEW_TYPE = "story-weaver-corkboard";

// src/views/HoverPopup.ts
var import_obsidian9 = require("obsidian");
var HoverPopup = class extends import_obsidian9.Component {
  constructor(app) {
    super();
    this.popupElement = null;
    this.hoverTimeout = null;
    this.hideTimeout = null;
    this.isHovering = false;
    this.app = app;
    this.projectService = ProjectService.getInstance(app);
  }
  /**
   * 组件加载时初始化事件监听
   * Initialize event listeners when component loads
   */
  onload() {
    this.registerDomEvent(document, "mouseover", this.handleMouseOver.bind(this));
    this.registerDomEvent(document, "mouseout", this.handleMouseOut.bind(this));
    console.log("HoverPopup component loaded");
  }
  /**
   * 组件卸载时清理资源
   * Cleanup resources when component unloads
   */
  onunload() {
    this.hidePopup();
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
    if (this.hideTimeout) {
      clearTimeout(this.hideTimeout);
      this.hideTimeout = null;
    }
    console.log("HoverPopup component unloaded");
  }
  /**
   * 处理鼠标悬停事件
   * Handle mouse over events
   */
  handleMouseOver(event) {
    const target = event.target;
    const linkElement = this.findLinkElement(target);
    if (!linkElement) {
      return;
    }
    const linkPath = this.extractLinkPath(linkElement);
    if (!linkPath) {
      return;
    }
    const entityType = this.getEntityType(linkPath);
    if (!entityType) {
      return;
    }
    this.isHovering = true;
    this.hoverTimeout = setTimeout(async () => {
      if (this.isHovering) {
        await this.showPopover(linkElement, linkPath, entityType);
      }
    }, 500);
  }
  /**
   * 处理鼠标离开事件
   * Handle mouse out events
   */
  handleMouseOut(event) {
    const target = event.target;
    const linkElement = this.findLinkElement(target);
    if (linkElement) {
      this.isHovering = false;
      if (this.hoverTimeout) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = null;
      }
      this.hideTimeout = setTimeout(() => {
        if (!this.isHovering && !this.isHoveringPopup()) {
          this.hidePopup();
        }
      }, 300);
    }
  }
  /**
   * 查找链接元素
   * Find link element from target or its parents
   */
  findLinkElement(target) {
    var _a, _b;
    let current = target;
    while (current && current !== document.body) {
      if (current.classList.contains("internal-link") || current.hasAttribute("data-href") || current.tagName === "A" && ((_a = current.getAttribute("href")) == null ? void 0 : _a.startsWith("[[")) && ((_b = current.getAttribute("href")) == null ? void 0 : _b.endsWith("]]"))) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  /**
   * 提取链接路径
   * Extract link path from link element
   */
  extractLinkPath(linkElement) {
    let path = linkElement.getAttribute("data-href") || linkElement.getAttribute("href") || linkElement.textContent;
    if (!path) {
      return null;
    }
    path = path.trim();
    if (path.startsWith("[[") && path.endsWith("]]")) {
      path = path.slice(2, -2);
    }
    const pipeIndex = path.indexOf("|");
    if (pipeIndex !== -1) {
      path = path.substring(0, pipeIndex);
    }
    return path;
  }
  /**
   * 获取实体类型 (角色或地点)
   * Get entity type (character or location)
   */
  getEntityType(linkPath) {
    if (!this.projectService.currentProject) {
      return null;
    }
    const projectRoot = this.projectService.currentProject.rootPath;
    let fullPath = linkPath;
    if (!linkPath.includes("/")) {
      const characterPath = `${projectRoot}/20_\u89D2\u8272/${linkPath}.md`;
      const locationPath = `${projectRoot}/30_\u5730\u70B9/${linkPath}.md`;
      if (this.projectService.getCharacterData(characterPath)) {
        return "character";
      } else if (this.projectService.getLocationData(locationPath)) {
        return "location";
      }
    } else {
      if (linkPath.includes("/20_\u89D2\u8272/")) {
        return "character";
      } else if (linkPath.includes("/30_\u5730\u70B9/")) {
        return "location";
      }
    }
    return null;
  }
  /**
   * 显示悬浮窗
   * Show hover popup
   */
  async showPopover(linkElement, linkPath, entityType) {
    this.hidePopup();
    this.popupElement = document.createElement("div");
    this.popupElement.classList.add("story-weaver-hover-popup");
    this.renderLoadingState(this.popupElement, linkPath);
    this.positionAndShowPopup(this.popupElement, linkElement);
    this.addPopupEventListeners();
    try {
      const entityData = await this.getEntityData(linkPath, entityType);
      if (!entityData || !this.popupElement) {
        return;
      }
      this.renderPopupContent(this.popupElement, entityData, entityType);
    } catch (error) {
      console.error("Failed to load entity data:", error);
      if (this.popupElement) {
        this.renderErrorState(this.popupElement, linkPath);
      }
    }
  }
  /**
   * 渲染加载状态
   * Render loading state
   */
  renderLoadingState(container, linkPath) {
    container.innerHTML = "";
    container.classList.add("loading");
    const title = document.createElement("h3");
    title.textContent = linkPath;
    title.className = "hover-popup-title";
    container.appendChild(title);
    const loadingText = document.createElement("div");
    loadingText.textContent = "\u52A0\u8F7D\u4E2D...";
    loadingText.className = "hover-popup-loading";
    container.appendChild(loadingText);
  }
  /**
   * 渲染错误状态
   * Render error state
   */
  renderErrorState(container, linkPath) {
    container.innerHTML = "";
    container.classList.remove("loading");
    const title = document.createElement("h3");
    title.textContent = linkPath;
    title.className = "hover-popup-title";
    container.appendChild(title);
    const errorText = document.createElement("div");
    errorText.textContent = "\u52A0\u8F7D\u5931\u8D25";
    errorText.className = "hover-popup-error";
    container.appendChild(errorText);
  }
  /**
   * 隐藏悬浮窗
   * Hide hover popup
   */
  hidePopup() {
    if (this.popupElement) {
      this.popupElement.remove();
      this.popupElement = null;
    }
  }
  /**
   * 获取实体数据
   * Get entity data by path and type
   */
  async getEntityData(linkPath, entityType) {
    if (!this.projectService.currentProject) {
      return null;
    }
    const projectRoot = this.projectService.currentProject.rootPath;
    let fullPath = linkPath;
    if (!linkPath.includes("/")) {
      if (entityType === "character") {
        fullPath = `${projectRoot}/20_\u89D2\u8272/${linkPath}.md`;
      } else {
        fullPath = `${projectRoot}/30_\u5730\u70B9/${linkPath}.md`;
      }
    }
    let entityData = null;
    if (entityType === "character") {
      entityData = this.projectService.getCharacterData(fullPath);
    } else {
      entityData = this.projectService.getLocationData(fullPath);
    }
    if (!entityData) {
      return null;
    }
    const summary = await this.extractNoteSummary(fullPath);
    return {
      ...entityData,
      summary
    };
  }
  /**
   * 提取笔记摘要
   * Extract note summary from file content
   */
  async extractNoteSummary(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || file.constructor.name !== "TFile") {
        return "";
      }
      const content = await this.app.vault.read(file);
      const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---\n?/, "");
      const lines = contentWithoutFrontmatter.split("\n");
      let summary = "";
      for (const line of lines) {
        const trimmedLine = line.trim();
        if (trimmedLine && !trimmedLine.startsWith("#") && !trimmedLine.startsWith("*") && !trimmedLine.startsWith("-") && !trimmedLine.startsWith("\u2022") && !trimmedLine.match(/^\d+\./) && trimmedLine.length > 10) {
          summary = trimmedLine;
          break;
        }
      }
      if (summary.length > 120) {
        summary = summary.substring(0, 117) + "...";
      }
      return summary;
    } catch (error) {
      console.warn(`Failed to extract summary from ${filePath}:`, error);
      return "";
    }
  }
  /**
   * 渲染悬浮窗内容
   * Render popup content
   */
  renderPopupContent(container, entityData, entityType) {
    container.innerHTML = "";
    container.classList.remove("loading");
    if (entityType === "character") {
      this.renderCharacterContent(container, entityData);
    } else {
      this.renderLocationContent(container, entityData);
    }
  }
  /**
   * 定位并显示悬浮窗
   * Position and show popup
   */
  positionAndShowPopup(popup, linkElement) {
    document.body.appendChild(popup);
    const linkRect = linkElement.getBoundingClientRect();
    const popupRect = popup.getBoundingClientRect();
    let left = linkRect.left + linkRect.width / 2 - popupRect.width / 2;
    let top = linkRect.top - popupRect.height - 8;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    if (left < 8) {
      left = 8;
    } else if (left + popupRect.width > viewportWidth - 8) {
      left = viewportWidth - popupRect.width - 8;
    }
    if (top < 8) {
      top = linkRect.bottom + 8;
      popup.classList.add("bottom-arrow");
    }
    popup.style.position = "fixed";
    popup.style.left = `${left}px`;
    popup.style.top = `${top}px`;
    popup.style.zIndex = "1000";
  }
  /**
   * 渲染角色信息内容
   * Render character information content
   */
  renderCharacterContent(container, character) {
    const title = document.createElement("h3");
    title.textContent = character.name;
    title.className = "hover-popup-title";
    container.appendChild(title);
    const infoContainer = document.createElement("div");
    infoContainer.className = "hover-popup-info";
    container.appendChild(infoContainer);
    if (character.faction) {
      const factionEl = document.createElement("div");
      factionEl.textContent = `\u9635\u8425: ${character.faction}`;
      factionEl.className = "hover-popup-field";
      infoContainer.appendChild(factionEl);
    }
    if (character.age > 0) {
      const ageEl = document.createElement("div");
      ageEl.textContent = `\u5E74\u9F84: ${character.age}`;
      ageEl.className = "hover-popup-field";
      infoContainer.appendChild(ageEl);
    }
    if (character.status) {
      const statusEl = document.createElement("div");
      statusEl.className = "hover-popup-field";
      const statusLabel = document.createElement("span");
      statusLabel.textContent = "\u72B6\u6001: ";
      statusEl.appendChild(statusLabel);
      const statusSpan = document.createElement("span");
      statusSpan.textContent = this.getStatusText(character.status);
      statusSpan.className = `status-${character.status}`;
      statusEl.appendChild(statusSpan);
      infoContainer.appendChild(statusEl);
    }
    const displayDescription = character.description || character.summary;
    if (displayDescription) {
      const descContainer = document.createElement("div");
      descContainer.className = "hover-popup-description";
      const descLabel = document.createElement("div");
      descLabel.textContent = character.description ? "\u63CF\u8FF0:" : "\u6458\u8981:";
      descLabel.className = "hover-popup-label";
      descContainer.appendChild(descLabel);
      const descText = document.createElement("div");
      descText.textContent = displayDescription;
      descText.className = "hover-popup-text";
      descContainer.appendChild(descText);
      container.appendChild(descContainer);
    }
    if (character.goals) {
      const goalsContainer = document.createElement("div");
      goalsContainer.className = "hover-popup-goals";
      const goalsLabel = document.createElement("div");
      goalsLabel.textContent = "\u76EE\u6807:";
      goalsLabel.className = "hover-popup-label";
      goalsContainer.appendChild(goalsLabel);
      const goalsText = document.createElement("div");
      goalsText.textContent = character.goals;
      goalsText.className = "hover-popup-text";
      goalsContainer.appendChild(goalsText);
      container.appendChild(goalsContainer);
    }
    if (character.appearances && character.appearances.length > 0) {
      const appearancesContainer = document.createElement("div");
      appearancesContainer.className = "hover-popup-appearances";
      const appearancesText = document.createElement("div");
      appearancesText.textContent = `\u51FA\u73B0\u573A\u666F: ${character.appearances.length} \u4E2A`;
      appearancesText.className = "hover-popup-field";
      appearancesContainer.appendChild(appearancesText);
      container.appendChild(appearancesContainer);
    }
  }
  /**
   * 渲染地点信息内容
   * Render location information content
   */
  renderLocationContent(container, location) {
    const title = document.createElement("h3");
    title.textContent = location.name;
    title.className = "hover-popup-title";
    container.appendChild(title);
    const infoContainer = document.createElement("div");
    infoContainer.className = "hover-popup-info";
    container.appendChild(infoContainer);
    if (location.region) {
      const regionEl = document.createElement("div");
      regionEl.textContent = `\u533A\u57DF: ${location.region}`;
      regionEl.className = "hover-popup-field";
      infoContainer.appendChild(regionEl);
    }
    if (location.significance) {
      const significanceEl = document.createElement("div");
      significanceEl.textContent = `\u91CD\u8981\u6027: ${location.significance}`;
      significanceEl.className = "hover-popup-field";
      infoContainer.appendChild(significanceEl);
    }
    const displayDescription = location.description || location.summary;
    if (displayDescription) {
      const descContainer = document.createElement("div");
      descContainer.className = "hover-popup-description";
      const descLabel = document.createElement("div");
      descLabel.textContent = location.description ? "\u63CF\u8FF0:" : "\u6458\u8981:";
      descLabel.className = "hover-popup-label";
      descContainer.appendChild(descLabel);
      const descText = document.createElement("div");
      descText.textContent = displayDescription;
      descText.className = "hover-popup-text";
      descContainer.appendChild(descText);
      container.appendChild(descContainer);
    }
    if (location.scenes && location.scenes.length > 0) {
      const scenesContainer = document.createElement("div");
      scenesContainer.className = "hover-popup-scenes";
      const scenesText = document.createElement("div");
      scenesText.textContent = `\u76F8\u5173\u573A\u666F: ${location.scenes.length} \u4E2A`;
      scenesText.className = "hover-popup-field";
      scenesContainer.appendChild(scenesText);
      container.appendChild(scenesContainer);
    }
    if (location.connectedLocations && location.connectedLocations.length > 0) {
      const connectionsContainer = document.createElement("div");
      connectionsContainer.className = "hover-popup-connections";
      const connectionsLabel = document.createElement("div");
      connectionsLabel.textContent = "\u76F8\u8FDE\u5730\u70B9:";
      connectionsLabel.className = "hover-popup-label";
      connectionsContainer.appendChild(connectionsLabel);
      const connectionsList = document.createElement("div");
      connectionsList.className = "hover-popup-list";
      connectionsContainer.appendChild(connectionsList);
      location.connectedLocations.slice(0, 3).forEach((conn) => {
        const connItem = document.createElement("div");
        connItem.textContent = `\u2022 ${conn}`;
        connItem.className = "hover-popup-list-item";
        connectionsList.appendChild(connItem);
      });
      if (location.connectedLocations.length > 3) {
        const moreItem = document.createElement("div");
        moreItem.textContent = `... \u8FD8\u6709 ${location.connectedLocations.length - 3} \u4E2A`;
        moreItem.className = "hover-popup-list-item more";
        connectionsList.appendChild(moreItem);
      }
      container.appendChild(connectionsContainer);
    }
  }
  /**
   * 获取状态文本
   * Get status text for display
   */
  getStatusText(status) {
    const statusMap = {
      "alive": "\u5B58\u6D3B",
      "dead": "\u6B7B\u4EA1",
      "unknown": "\u672A\u77E5"
    };
    return statusMap[status] || status;
  }
  /**
   * 添加悬浮窗事件监听
   * Add popup event listeners
   */
  addPopupEventListeners() {
    if (!this.popupElement) {
      return;
    }
    this.registerDomEvent(this.popupElement, "mouseenter", () => {
      this.isHovering = true;
      if (this.hideTimeout) {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = null;
      }
    });
    this.registerDomEvent(this.popupElement, "mouseleave", () => {
      this.isHovering = false;
      this.hideTimeout = setTimeout(() => {
        if (!this.isHovering) {
          this.hidePopup();
        }
      }, 300);
    });
  }
  /**
   * 检查是否正在悬停在悬浮窗上
   * Check if currently hovering over popup
   */
  isHoveringPopup() {
    if (!this.popupElement) {
      return false;
    }
    return this.popupElement.matches(":hover");
  }
};

// src/settings/SettingsTab.ts
var import_obsidian10 = require("obsidian");
var StoryWeaverSettingsTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u7EC7\u6587\u8005 (Story Weaver) \u8BBE\u7F6E" });
    this.addLicenseSection(containerEl);
    this.addBasicSettings(containerEl);
    this.addFolderStructureSettings(containerEl);
  }
  /**
   * 添加许可证信息部分
   * Add license information section
   */
  addLicenseSection(containerEl) {
    containerEl.createEl("h3", { text: "\u8BB8\u53EF\u8BC1\u4FE1\u606F" });
    const licenseStatusEl = containerEl.createDiv("license-status");
    licenseStatusEl.style.cssText = `
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 8px;
      border: 1px solid var(--background-modifier-border);
      background: var(--background-secondary);
    `;
    const isFullVersion = this.plugin.isFullVersion();
    const licenseDisplayName = this.plugin.getLicenseDisplayName();
    const statusIcon = isFullVersion ? "\u2705" : "\u26A0\uFE0F";
    const statusColor = isFullVersion ? "#10b981" : "#f59e0b";
    licenseStatusEl.createEl("p", {
      text: `${statusIcon} \u5F53\u524D\u7248\u672C\uFF1A${licenseDisplayName}`,
      attr: { style: `color: ${statusColor}; font-weight: 600; margin-bottom: 10px;` }
    });
    if (isFullVersion) {
      licenseStatusEl.createEl("p", {
        text: `\u6FC0\u6D3B\u65F6\u95F4\uFF1A${new Date(this.plugin.settings.activatedAt).toLocaleString()}`,
        attr: { style: "color: var(--text-muted); font-size: 14px; margin: 0;" }
      });
    } else {
      licenseStatusEl.createEl("p", {
        text: "\u8BD5\u7528\u7248\u9650\u5236\uFF1A\u6700\u591A\u521B\u5EFA 1 \u4E2A\u9879\u76EE",
        attr: { style: "color: var(--text-muted); font-size: 14px; margin: 0;" }
      });
    }
    if (!isFullVersion) {
      let activationCodeInput;
      new import_obsidian10.Setting(containerEl).setName("\u6FC0\u6D3B\u7801").setDesc("\u8F93\u5165\u6FC0\u6D3B\u7801\u5347\u7EA7\u5230\u6B63\u5F0F\u7248\uFF0C\u4EAB\u53D7\u5B8C\u6574\u529F\u80FD").addText((text) => {
        activationCodeInput = text.inputEl;
        text.setPlaceholder("\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801").setValue("").onChange(async (value) => {
        });
      }).addButton((button) => {
        button.setButtonText("\u6FC0\u6D3B").setCta().onClick(async () => {
          const code = activationCodeInput.value.trim();
          if (!code) {
            new import_obsidian10.Notice("\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801");
            return;
          }
          button.setButtonText("\u6FC0\u6D3B\u4E2D...");
          button.setDisabled(true);
          try {
            const result = await this.plugin.activateFullVersion(code);
            if (result.success) {
              new import_obsidian10.Notice(result.message);
              this.display();
            } else {
              new import_obsidian10.Notice(result.message);
            }
          } catch (error) {
            new import_obsidian10.Notice("\u6FC0\u6D3B\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
            console.error("Activation error:", error);
          } finally {
            button.setButtonText("\u6FC0\u6D3B");
            button.setDisabled(false);
          }
        });
      });
      const purchaseEl = containerEl.createDiv("purchase-info");
      purchaseEl.style.cssText = `
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 8px;
        background: var(--background-primary);
        border: 1px solid var(--background-modifier-border);
      `;
      purchaseEl.createEl("h4", {
        text: "\u{1F6D2} \u83B7\u53D6\u6FC0\u6D3B\u7801",
        attr: { style: "margin-bottom: 10px;" }
      });
      purchaseEl.createEl("p", {
        text: "\u5982\u9700\u8D2D\u4E70\u6FC0\u6D3B\u7801\uFF0C\u8BF7\u8BBF\u95EE\u5B98\u65B9\u7F51\u7AD9\u3002",
        attr: { style: "margin-bottom: 10px; color: var(--text-muted);" }
      });
      const contactEl = purchaseEl.createEl("p", {
        attr: { style: "margin: 0; font-size: 14px;" }
      });
      contactEl.createEl("span", { text: "\u5B98\u65B9\u7F51\u7AD9\uFF1A" });
      contactEl.createEl("a", {
        text: "http://www.moaono.com/obsidian-storyweaver",
        attr: {
          href: "http://www.moaono.com/obsidian-storyweaver",
          target: "_blank",
          style: "color: var(--color-accent);"
        }
      });
    }
  }
  /**
   * 添加基本设置
   * Add basic settings
   */
  addBasicSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u57FA\u672C\u8BBE\u7F6E" });
    new import_obsidian10.Setting(containerEl).setName("\u9ED8\u8BA4\u9879\u76EE\u8DEF\u5F84").setDesc("\u65B0\u5EFA\u9879\u76EE\u7684\u9ED8\u8BA4\u5B58\u653E\u4F4D\u7F6E").addText((text) => text.setPlaceholder("\u4F8B\u5982\uFF1AProjects/Writing").setValue(this.plugin.settings.defaultProjectPath).onChange(async (value) => {
      this.plugin.settings.defaultProjectPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u81EA\u52A8\u4FDD\u5B58\u95F4\u9694").setDesc("\u81EA\u52A8\u4FDD\u5B58\u9879\u76EE\u6570\u636E\u7684\u65F6\u95F4\u95F4\u9694\uFF08\u79D2\uFF09").addSlider((slider) => slider.setLimits(10, 300, 10).setValue(this.plugin.settings.autoSaveInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoSaveInterval = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u8C03\u8BD5\u6A21\u5F0F").setDesc("\u542F\u7528\u8C03\u8BD5\u6A21\u5F0F\u4EE5\u83B7\u53D6\u66F4\u8BE6\u7EC6\u7684\u65E5\u5FD7\u4FE1\u606F").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
  }
  /**
   * 添加文件夹结构设置
   * Add folder structure settings
   */
  addFolderStructureSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u6587\u4EF6\u5939\u7ED3\u6784" });
    const folderStructure = this.plugin.settings.folderStructure;
    new import_obsidian10.Setting(containerEl).setName("\u7A3F\u4EF6\u6587\u4EF6\u5939").setDesc("\u5B58\u653E\u7AE0\u8282\u548C\u573A\u666F\u6587\u4EF6\u7684\u6587\u4EF6\u5939\u540D\u79F0").addText((text) => text.setValue(folderStructure.scenes).onChange(async (value) => {
      this.plugin.settings.folderStructure.scenes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u89D2\u8272\u6587\u4EF6\u5939").setDesc("\u5B58\u653E\u89D2\u8272\u8BBE\u5B9A\u6587\u4EF6\u7684\u6587\u4EF6\u5939\u540D\u79F0").addText((text) => text.setValue(folderStructure.characters).onChange(async (value) => {
      this.plugin.settings.folderStructure.characters = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u5730\u70B9\u6587\u4EF6\u5939").setDesc("\u5B58\u653E\u5730\u70B9\u8BBE\u5B9A\u6587\u4EF6\u7684\u6587\u4EF6\u5939\u540D\u79F0").addText((text) => text.setValue(folderStructure.locations).onChange(async (value) => {
      this.plugin.settings.folderStructure.locations = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u8BBE\u5B9A\u6587\u4EF6\u5939").setDesc("\u5B58\u653E\u4E16\u754C\u89C2\u8BBE\u5B9A\u6587\u4EF6\u7684\u6587\u4EF6\u5939\u540D\u79F0").addText((text) => text.setValue(folderStructure.settings).onChange(async (value) => {
      this.plugin.settings.folderStructure.settings = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian10.Setting(containerEl).setName("\u6A21\u677F\u6587\u4EF6\u5939").setDesc("\u5B58\u653E\u6A21\u677F\u6587\u4EF6\u7684\u6587\u4EF6\u5939\u540D\u79F0").addText((text) => text.setValue(folderStructure.templates).onChange(async (value) => {
      this.plugin.settings.folderStructure.templates = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  defaultProjectPath: "",
  autoSaveInterval: 30,
  debugMode: false,
  folderStructure: {
    scenes: "10_\u7A3F\u4EF6",
    characters: "20_\u89D2\u8272",
    locations: "30_\u5730\u70B9",
    settings: "40_\u8BBE\u5B9A",
    templates: "80_\u6A21\u677F",
    resources: "70_\u8D44\u6E90",
    exports: "60_\u5BFC\u51FA"
  },
  defaultCharacterTemplate: "",
  defaultLocationTemplate: "",
  defaultSceneTemplate: "",
  templateSettings: {
    characterTemplate: "",
    locationTemplate: "",
    sceneTemplate: ""
  },
  licenseType: "trial",
  activationCode: "",
  activatedAt: null
};
var StoryWeaverPlugin = class extends import_obsidian11.Plugin {
  /**
   * 插件加载时调用
   * Called when the plugin is loaded
   */
  async onload() {
    console.log("Loading Story Weaver Plugin...");
    await this.loadSettings();
    this.activationService = new ActivationService();
    await this.syncLicenseStatus();
    this.projectService = ProjectService.getInstance(this.app);
    this.projectService.updateSettings(this.settings);
    this.templateService = new TemplateService(this.app);
    this.dashboardRenderer = new DashboardRenderer(this.app, this.projectService);
    this.hoverPopup = new HoverPopup(this.app);
    this.addChild(this.hoverPopup);
    this.immersiveWritingService = new ImmersiveWritingService(this.app, this.projectService);
    this.registerCommands();
    this.registerViews();
    this.addSettingTab(new StoryWeaverSettingsTab(this.app, this));
    this.registerEventListeners();
    this.registerDashboardProcessor();
    this.app.workspace.onLayoutReady(() => {
      this.autoLoadProjectOnStartup();
    });
    console.log("Story Weaver Plugin loaded successfully");
  }
  /**
   * 插件启动时自动加载项目
   * Auto-load project on plugin startup
   */
  async autoLoadProjectOnStartup() {
    try {
      console.log("Attempting to auto-load project on startup...");
      const loaded = await this.projectService.autoLoadProject();
      if (loaded) {
        console.log("Project auto-loaded successfully on startup");
        this.notifyViewsProjectLoaded();
      } else {
        console.log("No project found to auto-load on startup");
      }
    } catch (error) {
      console.error("Failed to auto-load project on startup:", error);
    }
  }
  /**
   * 通知所有视图项目已加载
   * Notify all views that project is loaded
   */
  notifyViewsProjectLoaded() {
    const outlineLeaves = this.app.workspace.getLeavesOfType("story-weaver-outline");
    outlineLeaves.forEach((leaf) => {
      if (leaf.view instanceof OutlineView) {
        leaf.view.refresh();
      }
    });
    const timelineLeaves = this.app.workspace.getLeavesOfType("story-weaver-timeline");
    timelineLeaves.forEach((leaf) => {
      if (leaf.view instanceof TimelineView) {
        leaf.view.refresh();
      }
    });
    const corkboardLeaves = this.app.workspace.getLeavesOfType("story-weaver-corkboard");
    corkboardLeaves.forEach((leaf) => {
      if (leaf.view instanceof CorkboardView) {
        leaf.view.refresh();
      }
    });
  }
  /**
   * 插件卸载时调用
   * Called when the plugin is unloaded
   */
  onunload() {
    console.log("Unloading Story Weaver Plugin...");
    this.cleanup();
    ProjectService.destroyInstance();
    console.log("Story Weaver Plugin unloaded");
  }
  /**
   * 注册插件命令
   * Register plugin commands
   */
  registerCommands() {
    this.addCommand({
      id: "create-new-project",
      name: "\u7EC7\u6587\u8005\uFF1A\u521B\u5EFA\u65B0\u5199\u4F5C\u9879\u76EE",
      callback: () => {
        this.createNewProject();
      }
    });
    this.addCommand({
      id: "open-outline-view",
      name: "\u7EC7\u6587\u8005\uFF1A\u6253\u5F00\u5927\u7EB2\u89C6\u56FE",
      callback: () => {
        this.openOutlineView();
      }
    });
    this.addCommand({
      id: "open-corkboard-view",
      name: "\u7EC7\u6587\u8005\uFF1A\u6253\u5F00\u770B\u677F\u89C6\u56FE",
      callback: () => {
        this.openCorkboardView();
      }
    });
    this.addCommand({
      id: "open-timeline-view",
      name: "\u7EC7\u6587\u8005\uFF1A\u6253\u5F00\u65F6\u95F4\u7EBF\u89C6\u56FE",
      callback: () => {
        this.openTimelineView();
      }
    });
    this.addCommand({
      id: "open-scene-info-panel",
      name: "\u7EC7\u6587\u8005\uFF1A\u6253\u5F00\u573A\u666F\u4FE1\u606F\u9762\u677F",
      callback: () => {
        this.openSceneInfoPanel();
      }
    });
    this.addCommand({
      id: "create-default-templates",
      name: "\u7EC7\u6587\u8005\uFF1A\u521B\u5EFA\u9ED8\u8BA4\u6A21\u677F\u6587\u4EF6",
      callback: () => {
        this.createDefaultTemplates();
      }
    });
  }
  /**
   * 注册自定义视图
   * Register custom views
   */
  registerViews() {
    this.registerView(
      SceneInfoPanel.VIEW_TYPE,
      (leaf) => new SceneInfoPanel(leaf, this.projectService)
    );
    this.registerView(
      OutlineView.VIEW_TYPE,
      (leaf) => new OutlineView(leaf, this.projectService)
    );
    this.registerView(
      TimelineView.VIEW_TYPE,
      (leaf) => new TimelineView(leaf, this.projectService)
    );
    console.log("Scene Info Panel, Outline View, and Timeline View registered");
  }
  /**
   * 注册 Markdown 后处理器
   * Register markdown post processor
   */
  registerDashboardProcessor() {
    this.registerMarkdownPostProcessor(async (element, context) => {
      await this.dashboardRenderer.processMarkdown(element, context);
    });
  }
  /**
   * 注册事件监听器
   * Register event listeners
   */
  registerEventListeners() {
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        this.onFileCreated(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        this.onFileDeleted(file);
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", (file, oldPath) => {
        this.onFileRenamed(file, oldPath);
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.onMetadataChanged(file);
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        this.onActiveLeafChanged(leaf);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        this.onFileMenu(menu, file);
      })
    );
  }
  /**
   * 清理资源
   * Cleanup resources
   */
  cleanup() {
    if (this.dashboardRenderer) {
      this.dashboardRenderer.unload();
    }
    if (this.hoverPopup) {
      this.removeChild(this.hoverPopup);
    }
    if (this.immersiveWritingService) {
      this.immersiveWritingService.destroy();
    }
    console.log("Cleanup completed");
  }
  /**
   * 创建新写作项目
   * Create new writing project
   */
  async createNewProject() {
    const currentLicenseType = this.activationService.checkLocalLicenseStatus();
    if (currentLicenseType !== this.settings.licenseType) {
      this.settings.licenseType = currentLicenseType;
      await this.saveSettings();
      this.projectService.updateSettings(this.settings);
    }
    const modal = new ProjectCreationModal(
      this.app,
      this.projectService,
      this.activationService,
      this.settings.licenseType
    );
    modal.open();
  }
  /**
   * 打开大纲视图
   * Open outline view
   */
  async openOutlineView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(OutlineView.VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeftLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: OutlineView.VIEW_TYPE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * 打开看板视图
   * Open corkboard view
   */
  async openCorkboardView() {
    console.log("Open corkboard view - to be implemented in later tasks");
  }
  /**
   * 打开时间线视图
   * Open timeline view
   */
  async openTimelineView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(TimelineView.VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: TimelineView.VIEW_TYPE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * 打开场景信息面板
   * Open scene info panel
   */
  async openSceneInfoPanel() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(SceneInfoPanel.VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: SceneInfoPanel.VIEW_TYPE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * 文件创建事件处理
   * Handle file creation event
   */
  async onFileCreated(file) {
    console.log(`File created: ${file.path}`);
    if (file.extension === "md") {
      setTimeout(async () => {
        const result = await this.templateService.applyTemplateToNewFile(file);
        if (result.success) {
          console.log(`Template applied: ${result.templateType} template to ${file.path}`);
        } else if (result.error && !result.error.includes("File not in template-applicable folder")) {
          console.warn(`Failed to apply template to ${file.path}: ${result.error}`);
        }
      }, 100);
    }
  }
  /**
   * 文件删除事件处理
   * Handle file deletion event
   */
  onFileDeleted(file) {
    console.log(`File deleted: ${file.path}`);
  }
  /**
   * 文件重命名事件处理
   * Handle file rename event
   */
  onFileRenamed(file, oldPath) {
    console.log(`File renamed: ${oldPath} -> ${file.path}`);
  }
  /**
   * 元数据变化事件处理
   * Handle metadata change event
   */
  onMetadataChanged(file) {
    console.log(`Metadata changed: ${file.path}`);
  }
  /**
   * 活动叶子变化事件处理
   * Handle active leaf change event
   */
  onActiveLeafChanged(leaf) {
    if (leaf && leaf.view.getViewType() === "markdown") {
      const file = this.app.workspace.getActiveFile();
      if (file) {
        console.log(`Active file changed: ${file.path}`);
      }
    }
  }
  /**
   * 文件菜单事件处理 (右键菜单)
   * Handle file menu event (context menu)
   */
  onFileMenu(menu, file) {
    if (!(file instanceof import_obsidian11.TFolder)) {
      return;
    }
    if (!this.projectService.currentProject) {
      return;
    }
    const projectRoot = this.projectService.currentProject.rootPath;
    const scenesPath = `${projectRoot}/10_\u7A3F\u4EF6`;
    if (!file.path.startsWith(scenesPath)) {
      return;
    }
    const hasScenes = this.hasSceneFiles(file);
    if (!hasScenes) {
      return;
    }
    menu.addItem((item) => {
      item.setTitle("\u5408\u5E76\u9605\u8BFB/\u5199\u4F5C").setIcon("book-open").onClick(async () => {
        await this.mergeChapterForWriting(file.path);
      });
    });
  }
  /**
   * 创建默认模板文件
   * Create default template files
   */
  async createDefaultTemplates() {
    try {
      if (!this.projectService.currentProject) {
        console.warn("No project loaded. Please create or load a project first.");
        return;
      }
      await this.templateService.createDefaultTemplateFiles();
      console.log("Default template files created successfully");
    } catch (error) {
      console.error("Failed to create default template files:", error);
    }
  }
  /**
   * 检查文件夹是否包含场景文件
   * Check if folder contains scene files
   */
  hasSceneFiles(folder) {
    const files = this.app.vault.getFiles();
    return files.some(
      (file) => file.path.startsWith(folder.path) && file.extension === "md" && file.path !== folder.path
    );
  }
  /**
   * 合并章节进行写作
   * Merge chapter for writing
   */
  async mergeChapterForWriting(chapterPath) {
    try {
      if (!this.projectService.currentProject) {
        console.warn("No project loaded");
        return;
      }
      await this.immersiveWritingService.openMergedChapterEditor(chapterPath);
    } catch (error) {
      console.error("Failed to merge chapter for writing:", error);
    }
  }
  /**
   * 获取 ProjectService 实例
   * Get ProjectService instance
   */
  getProjectService() {
    return this.projectService;
  }
  /**
   * 获取当前项目数据
   * Get current project data
   */
  getCurrentProject() {
    return this.projectService.currentProject;
  }
  /**
   * 加载设置
   * Load settings
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * 保存设置
   * Save settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * 激活正式版
   * Activate full version
   */
  async activateFullVersion(activationCode) {
    try {
      console.log(`\u{1F511} Attempting to activate with code: ${activationCode}`);
      const result = await this.activationService.verifyActivationCode(activationCode);
      if (result.success) {
        this.settings.licenseType = "full";
        this.settings.activationCode = activationCode;
        this.settings.activatedAt = new Date().toISOString();
        await this.saveSettings();
        this.activationService.saveLicenseInfo("full", activationCode);
        this.projectService.updateSettings(this.settings);
        this.onLicenseStatusChanged("full");
        console.log(`\u2705 Full version activated successfully`);
      }
      return {
        success: result.success,
        message: result.message
      };
    } catch (error) {
      console.error("\u274C Activation failed:", error);
      return {
        success: false,
        message: "\u6FC0\u6D3B\u8FC7\u7A0B\u4E2D\u53D1\u751F\u9519\u8BEF\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5"
      };
    }
  }
  /**
   * 许可证状态变化时的处理
   * Handle license status change
   */
  onLicenseStatusChanged(newLicenseType) {
    console.log(`\u{1F4C4} License status changed to: ${newLicenseType}`);
    this.updateUIForLicenseChange(newLicenseType);
  }
  /**
   * 为许可证变化更新UI
   * Update UI for license change
   */
  updateUIForLicenseChange(licenseType) {
    console.log(`\u{1F504} UI updated for license type: ${ActivationService.getLicenseDisplayName(licenseType)}`);
  }
  /**
   * 同步许可证状态
   * Sync license status
   */
  async syncLicenseStatus() {
    try {
      const localLicenseType = this.activationService.checkLocalLicenseStatus();
      if (localLicenseType !== this.settings.licenseType) {
        console.log(`\u{1F4C4} Syncing license status: ${this.settings.licenseType} -> ${localLicenseType}`);
        this.settings.licenseType = localLicenseType;
        if (localLicenseType === "full") {
          const licenseInfo = this.activationService.loadLicenseInfo();
          if (licenseInfo) {
            this.settings.activationCode = licenseInfo.activationCode;
            this.settings.activatedAt = licenseInfo.activatedAt;
          }
        }
        await this.saveSettings();
        console.log(`\u2705 License status synced to: ${ActivationService.getLicenseDisplayName(localLicenseType)}`);
      }
    } catch (error) {
      console.error("\u274C Failed to sync license status:", error);
    }
  }
  /**
   * 检查是否为正式版
   * Check if full version
   */
  isFullVersion() {
    return ActivationService.isFullVersion(this.settings.licenseType);
  }
  /**
   * 获取许可证显示名称
   * Get license display name
   */
  getLicenseDisplayName() {
    return ActivationService.getLicenseDisplayName(this.settings.licenseType);
  }
  /**
   * 获取激活服务实例
   * Get activation service instance
   */
  getActivationService() {
    return this.activationService;
  }
};
